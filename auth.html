
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Authentication and Account Management &#8212; openEO Python Client 0.12.0a1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="User-Defined Functions (UDF) explained" href="udf.html" />
    <link rel="prev" title="User-Defined Processes" href="udp.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="authentication-and-account-management">
<span id="authentication-chapter"></span><h1>Authentication and Account Management<a class="headerlink" href="#authentication-and-account-management" title="Permalink to this heading">¶</a></h1>
<p>While a couple of openEO operations can be done
anonymously, most of the interesting parts
of the API require you to identify as a registered
user.
The openEO API specifies two ways to authenticate
as a user:</p>
<ul class="simple">
<li><p>OpenID Connect (recommended, but not always straightforward to use)</p></li>
<li><p>Basic HTTP Authentication (not recommended, but practically easier in some situations)</p></li>
</ul>
<p>To illustrate how to authenticate with the openEO Python Client Library,
we start form a back-end connection:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openeo</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;https://openeo.example.com&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="basic-http-auth">
<h2>Basic HTTP Auth<a class="headerlink" href="#basic-http-auth" title="Permalink to this heading">¶</a></h2>
<p>Let’s start with the easiest authentication method,
based on the Basic HTTP authentication scheme.
It is however <em>not recommended</em> for various reasons,
such as its limited <em>security</em> measures.
For example, if you are connecting to a back-end with a <code class="docutils literal notranslate"><span class="pre">http://</span></code> URL
instead of a <code class="docutils literal notranslate"><span class="pre">https://</span></code> one, you should certainly not use basic HTTP auth.</p>
<p>With these security related caveats out of the way, you authenticate
using your username and password like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_basic</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="s2">&quot;j0hn123&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Subsequent usage of the connection object <code class="docutils literal notranslate"><span class="pre">con</span></code> will
use authenticated calls.
For example, show information about the authenticated user:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">describe_account</span><span class="p">()</span>
<span class="go">{&#39;user_id&#39;: &#39;john&#39;}</span>
</pre></div>
</div>
</section>
<section id="openid-connect-based-authentication">
<h2>OpenID Connect Based Authentication<a class="headerlink" href="#openid-connect-based-authentication" title="Permalink to this heading">¶</a></h2>
<p>OpenID Connect (often abbreviated “OIDC”) is an identity layer on top of the OAuth 2.0 protocol.
It is a quite an extensive stack of interacting actors and protocols,
and an in-depth discussion of its architecture would lead us too far here.
However, in the context of working with openEO,
these OpenID Connect concepts are useful to understand:</p>
<ul>
<li><p>There is <strong>decoupling</strong> between:</p>
<ul class="simple">
<li><p>the <em>OpenID Connect identity provider</em> (the platform
that handles the authentication of the user)</p></li>
<li><p>the <em>openEO back-end</em>, which manages earth observation collections
and executes your algorithms</p></li>
</ul>
<p>Instead of managing the authentication procedure itself,
a back-end first forwards a user to the log-in page of
a OpenID Connect provider, such as an (external) organisation like Google or Microsoft.
The user can log in there with an existing account (or create a new one)
and then generally has to explicitly grant access
to basic profile information (e.g. email address)
that the back-end will use to identify the user.</p>
<p>Note that with this approach, the back-end does not have to
take care of all the security and privacy challenges
of properly handling user registration, authentication, etc.
Also, it allows the user to securely reuse an existing account
registered with an established organisation, instead of having
to register yet another account with some web service.</p>
</li>
<li><p>Your openEO script or application acts as
a so called <strong>OpenID Connect client</strong>, with an associated <strong>client ID</strong>.
This practically means that, apart from a user account,
you need a client ID as well (and often a client secret too)
when authenticating.</p>
<p>The details of how to obtain the client ID and secret largely
depend on the back-end and OpenID Connect provider:
you might have to register a client yourself,
or you might have to use an existing client ID.
Consult the openEO back-end (documentation)
about how to obtain client ID (and secret).</p>
</li>
<li><p>There are several possible “<strong>flows</strong>” (also called “grants”)
to complete the whole OpenID Connect authentication dance:</p>
<ul class="simple">
<li><p>Authorization Code Flow</p></li>
<li><p>Device Flow</p></li>
<li><p>Client Credentials Flow</p></li>
<li><p>Resource Owner Password flow</p></li>
<li><p>Refresh Token Flow</p></li>
</ul>
<p>Picking the right flow highly depends on your use case and context:
are you working interactively,
are you working in a browser based environment,
should your application be able to work
without user interaction in the background,
what does the OpenID Connect provider support,
…?</p>
</li>
</ul>
<p>OpenID Connect is clearly more complex than Basic HTTP Auth.
In the sections below we will discuss the practical details of each flow.</p>
<section id="general-options">
<h3>General options<a class="headerlink" href="#general-options" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p>A back-end might support <strong>multiple OpenID Connect providers</strong>.
If there is only one, the openEO Python Client Library will pick it automatically,
but if there are multiple you might get an exception like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OpenEoClientException</span><span class="p">:</span> <span class="n">No</span> <span class="n">provider_id</span> <span class="n">given</span><span class="o">.</span> <span class="n">Available</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;gl&#39;</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<p>Specify explicitly which provider to use with the <code class="docutils literal notranslate"><span class="pre">provider_id</span></code> argument, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">provider_id</span><span class="o">=</span><span class="s2">&quot;gl&quot;</span><span class="p">,</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="authorization-code-flow">
<h3>Authorization Code Flow<a class="headerlink" href="#authorization-code-flow" title="Permalink to this heading">¶</a></h3>
<p>This is the most popular and widely supported OpenID Connect flow
in the general web development world.
However, it requires an environment that can be hard to get
right when using the openEO Python Client Library in your application:</p>
<ul class="simple">
<li><p>You are working interactively (e.g. in a Jupyter notebook,
in a Python/IPython shell or running a Python script
manually)</p></li>
<li><p>You have access to a web browser
(preferably on the same machine as your application),
to authenticate with the OpenID Connect provider</p></li>
<li><p>That web browser has (network) access
to a temporary web server that will be spawn
by the openEO Python Client Library in your application.</p></li>
<li><p>The URL of the temporary web server is properly whitelisted
in the OpenID client’s “redirect URL” configuration
at the OpenID Connect provider’s side.</p></li>
</ul>
<p>The hardest part are the two last items.
If you just run your application locally on your machine,
the whole procedure is doable (using a <code class="docutils literal notranslate"><span class="pre">localhost</span></code> based web server).
But if you are working remotely
(e.g. on a hosted Jupyter platform),
it can be challenging or even impossible
to get the network access part right.</p>
<section id="basic-usage">
<h4>Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this heading">¶</a></h4>
<p>The bare essentials to run the authorization code flow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We assume here that you are running this locally
and that the OpenID Connect provider allows to use a wildcard <code class="docutils literal notranslate"><span class="pre">*</span></code>
in the redirect URL whitelist.
The <code class="docutils literal notranslate"><span class="pre">client_id</span></code> and <code class="docutils literal notranslate"><span class="pre">client_secret</span></code> string variables hold
the client ID and secret as discussed above.</p>
<p>What happens when running that <code class="docutils literal notranslate"><span class="pre">authenticate_oidc_authorization_code</span></code> call:</p>
<ul class="simple">
<li><p>the openEO Python Client Library will
try to trigger your browser to open new window,
pointing to a log-in page of the
OpenID Connect provider (e.g. Google or Microsoft).</p></li>
<li><p>You have to authenticate on this page (unless you are logged in already)
and allow the client (identified by <code class="docutils literal notranslate"><span class="pre">client_id</span></code>) access to the
basic account information, such as email address
(unless you already did that).</p></li>
<li><p>Meanwhile, the openEO Python Client Library
is running a short-living webserver in the background
to serve a “redirect URL”.</p></li>
<li><p>When you completed logging in and access granting
on the OpenID Connect provider website,
you are forwarded in your browser to this redirect URL.</p></li>
<li><p>Through the data provided in the request to the redirect URL,
the openEO Python Client Library can obtain the desired
tokens to set up authenticated communication with the back-end.</p></li>
</ul>
<p>When the above procedure completed successfully, your connection
is authenticated, and you should be able
to inspect the “user” as seen by the back-end, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">describe_account</span><span class="p">()</span>
<span class="go">{&#39;user_id&#39;: &#39;nIrHtS4rhk4ru7531RhtLHXd6Ou0AW3vHfg&#39;}</span>
</pre></div>
</div>
<p>The browser window should show a simple success page
that you can safely close.</p>
</section>
<section id="options-and-finetuning">
<h4>Options and finetuning<a class="headerlink" href="#options-and-finetuning" title="Permalink to this heading">¶</a></h4>
<p>The above example only covers the bare foundation
of the OpenID Connect Authorization code flow.
In a practical use case, you will probably need
some of the following finetuning options:</p>
<ul>
<li><p>The redirect URL is served by default on <code class="docutils literal notranslate"><span class="pre">localhost</span></code>
with a random port number.
Most OpenID Connect providers however do not support wildcards
in the redirect URL whitelist and require predefined fixed URLs.
Also, your networking situation might require you to use
a different hostname or IP address instead of <code class="docutils literal notranslate"><span class="pre">localhost</span></code>
to reach the short-living webserver.</p>
<p>Both the redirect URL <strong>hostname and port number</strong> can be specified
explicitly with the <cite>server_address</cite> argument, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">server_address</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;myhost.example.com&quot;</span><span class="p">,</span> <span class="mi">40878</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, the corresponding redirect URL to whitelist is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">myhost</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="mi">40878</span><span class="o">/</span><span class="n">callback</span>
</pre></div>
</div>
</li>
<li><p>As noted above, the openEO Python Client Library tries
to trigger your default browser
(on the same machine that your application is running)
to open a new window.
If this does not work
(e.g. you are working remotely in a non-graphical environment),
or you want to use another browser on another machine,
you can specify an alternative way to <strong>“handle” the URL</strong> that initiates
the OpenID Connect flow with the <code class="docutils literal notranslate"><span class="pre">webbrowser_open</span></code> argument.
For example, to just print the URL so you can visit it as you desire:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">webbrowser_open</span><span class="o">=</span><span class="k">lambda</span> <span class="n">url</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Visit this:&quot;</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the web browser you use to visit that URL must be able
to resolve and access the redirect URL
served on the machine where your application is running.</p>
</li>
<li><p>The short-living webserver only waits up to a certain time
for the request to the redirect URL.
During that time, your application is actively waiting
and not doing anything else.
You can increase or decrease the maximum <strong>waiting time</strong> (in seconds)
with the <code class="docutils literal notranslate"><span class="pre">timeout</span></code> argument.</p></li>
</ul>
</section>
</section>
<section id="device-flow">
<h3>Device Flow<a class="headerlink" href="#device-flow" title="Permalink to this heading">¶</a></h3>
<p>The device flow (also called device authorization grant)
is a relatively new OpenID Connect flow
and it is not as widely supported across different OpenID Connect Providers
as the other flows.
It provides a nice alternative that is roughly comparable
to the authorization code flow but without the previously mentioned issues related
to short-living webservers, network access and browser redirects.</p>
<p>The device flow is only suited for interactive use cases
and requires a web browser for the authentication
with the OpenID Connect provider.
However, it can be any web browser, even one on your mobile phone.
There is no networking magic required to be able to access
any short-living background webserver like with the authorization code flow.</p>
<p>To illustrate the flow, this is how to initiate the authentication:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_device</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This will print a message like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">authenticate</span><span class="p">:</span> <span class="n">visit</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">oidc</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">net</span><span class="o">/</span><span class="n">device</span>
<span class="ow">and</span> <span class="n">enter</span> <span class="n">the</span> <span class="n">user</span> <span class="n">code</span> <span class="s1">&#39;DTNY-KLNX&#39;</span><span class="o">.</span>
</pre></div>
</div>
<p>You should now visit this URL.
Usually it is intentionally a short URL to make it feasible to type it
instead of copy-pasting it (e.g. on another device).
Authenticate with the OpenID Connect provider and enter the user code
shown in the message.
Meanwhile, the openEO Python Client Library is actively polling the OpenID Connect
provider and when you successfully complete the authentication
and entering of the user code,
it will receive the necessary tokens for authenticated communication
with the back-end and print:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Authorized</span> <span class="n">successfully</span><span class="o">.</span>
</pre></div>
</div>
<p>In case of authentication failure, the openEO Python Client Library
will stop polling at some point and raise an exception.</p>
<p>Some additional options for this flow:</p>
<ul>
<li><p>By default, the messages containing the authentication URL, user code
and success message are printed with standard Python <code class="docutils literal notranslate"><span class="pre">print</span></code>.
You can provide a custom function to display them with the <code class="docutils literal notranslate"><span class="pre">display</span></code> option, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_device</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">display</span><span class="o">=</span><span class="k">lambda</span> <span class="n">msg</span><span class="p">:</span> <span class="n">render_popup</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>The openEO Python Client Library waits actively
for successful authentication, so your application is
hanging for a certain time.
You can increate or reduce this maximum polling time (in seconds)
with the <code class="docutils literal notranslate"><span class="pre">max_poll_time</span></code> argument.</p></li>
</ul>
</section>
<section id="client-credentials-flow">
<h3>Client Credentials Flow<a class="headerlink" href="#client-credentials-flow" title="Permalink to this heading">¶</a></h3>
<p>The Client Credentials flow directly uses the client ID and secret
to authenticate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_client_credentials</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>It does not involve interactive authentication through a web browser,
which makes it useful for <strong>non-interactive use cases</strong>.</p>
<p>The downside is of the Client Credentials flow is that it can
be challenging or even impossible with a given OpenID Connect provider,
to set up a client that supports this.
Also, your openEO back-end might not allow it, because technically
you are authenticating a <em>client</em>, and not a <em>user</em>.</p>
</section>
<section id="resource-owner-password-flow">
<h3>Resource Owner Password flow<a class="headerlink" href="#resource-owner-password-flow" title="Permalink to this heading">¶</a></h3>
<p>With the Resource Owner Password flow you directly pass
the user (and client) credentials:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_resource_owner_password_credentials</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
    <span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">,</span>
    <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Like the Client Credentials flow, it is useful for <strong>non-interactive uses cases</strong>.</p>
<p>However, usage of the Resource Owner Password flow is <strong>generally discouraged</strong>
because of its poor security features (e.g. OAuth/OIDC was designed
to avoid passing and storing user passwords unnecessarily).
It is also not widely supported across OpenID Connect providers,
probably due to its weak security measures.</p>
</section>
<section id="refresh-token-flow">
<h3>Refresh Token Flow<a class="headerlink" href="#refresh-token-flow" title="Permalink to this heading">¶</a></h3>
<p>When OpenID Connect authentication completes successfully,
the openID Python library receives an access token
to be used when doing authenticated calls to the back-end.
The access token usually has a short lifetime to reduce
the security risk when it would be stolen or intercepted.
The openID Python library also receives a <em>refresh token</em>
that can be used, through the Refresh Token flow,
to easily request a new access token,
without having to re-authenticate,
which makes it useful for <strong>non-interactive uses cases</strong>.</p>
<p>However, as it needs an existing refresh token,
the Refresh Token Flow requires
<strong>first to authenticate with one of the other flows</strong>
(but in practice this should not be done very often
because refresh tokens usually have a relatively long lifetime).
When doing the initial authentication,
you have to explicitly enable storage of the refresh token,
through the <code class="docutils literal notranslate"><span class="pre">store_refresh_token</span></code> argument, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">store_refresh_token</span><span class="o">=</span><span class="kc">True</span>
</pre></div>
</div>
<p>The refresh token will be stored in file in private file
in your home directory and will be used automatically
when authenticating with the Refresh Token Flow like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_refresh_token</span><span class="p">(</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span>
<span class="p">)</span>
</pre></div>
</div>
<p>You can also bootstrap the refresh token file
as described in <a class="reference internal" href="#oidc-auth-get-refresh-token"><span class="std std-ref">OpenID Connect refresh tokens</span></a></p>
</section>
</section>
<section id="auth-config-files-and-openeo-auth-helper-tool">
<span id="auth-configuration-files"></span><h2>Auth config files and <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> helper tool<a class="headerlink" href="#auth-config-files-and-openeo-auth-helper-tool" title="Permalink to this heading">¶</a></h2>
<p>The openEO Python Client Library provides some features and tools
that ease the usability and security challenges
that come with authentication (especially in case of OpenID Connect).</p>
<p>Note that the code examples above contain quite some <strong>passwords and other secrets</strong>
that should be kept safe from prying eyes.
It is bad practice to define these kind of secrets directly
in your scripts and source code because that makes it quite hard
to responsibly share or reuse your code.
Even worse is storing these secrets in your version control system,
where it might be near impossible to remove them again.
A better solution is to keep <strong>secrets in separate configuration or cache files</strong>,
outside of your normal source code tree
(to avoid committing them accidentally).</p>
<p>The openEO Python Client Library supports config files to store:
user names, passwords, client IDs, client secrets, etc,
so you don’t have to specify them always in your scripts and applications.</p>
<p>The openEO Python Client Library (when installed properly)
provides a command line tool <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> to bootstrap and manage
these configs and secrets.
It is a command line tool that provides various “subcommands”
and has built-in help:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth -h
usage: openeo-auth [-h] [--verbose]
                   {paths,config-dump,token-dump,add-basic,add-oidc,oidc-auth}
                   ...

Tool to manage openEO related authentication and configuration.

optional arguments:
  -h, --help            show this help message and exit

Subcommands:
  {paths,config-dump,token-dump,add-basic,add-oidc,oidc-auth}
    paths               Show paths to config/token files.
    config-dump         Dump config file.
...
</pre></div>
</div>
<p>For example, to see the expected paths of the config files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth paths
openEO auth config: /home/john/.config/openeo-python-client/auth-config.json (perms: 0o600, size: 1414B)
openEO OpenID Connect refresh token store: /home/john/.local/share/openeo-python-client/refresh-tokens.json (perms: 0o600, size: 846B)
</pre></div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">config-dump</span></code> and <code class="docutils literal notranslate"><span class="pre">token-dump</span></code> subcommands you can dump
the current configuration and stored refresh tokens, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth config-dump
### /home/john/.config/openeo-python-client/auth-config.json ###############
{
  &quot;backends&quot;: {
    &quot;https://openeo.example.com&quot;: {
      &quot;basic&quot;: {
        &quot;username&quot;: &quot;john&quot;,
        &quot;password&quot;: &quot;&lt;redacted&gt;&quot;,
        &quot;date&quot;: &quot;2020-07-24T13:40:50Z&quot;
...
</pre></div>
</div>
<p>The sensitive information (like passwords) are redacted by default.</p>
<section id="basic-http-auth-config">
<h3>Basic HTTP Auth config<a class="headerlink" href="#basic-http-auth-config" title="Permalink to this heading">¶</a></h3>
<p>With the <code class="docutils literal notranslate"><span class="pre">add-basic</span></code> subcommand you can add Basic HTTP Auth credentials
for a given back-end to the config.
It will interactively ask for username and password and
try if these credentials work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth add-basic https://openeo.example.com/
Enter username and press enter: john
Enter password and press enter:
Trying to authenticate with &#39;https://openeo.example.com&#39;
Successfully authenticated &#39;john&#39;
Saved credentials to &#39;/home/john/.config/openeo-python-client/auth-config.json&#39;
</pre></div>
</div>
<p>Now you can authenticate in your application without having to
specify username and password explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_basic</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="openid-connect-configs">
<h3>OpenID Connect configs<a class="headerlink" href="#openid-connect-configs" title="Permalink to this heading">¶</a></h3>
<p>Likewise, with the <code class="docutils literal notranslate"><span class="pre">add-oidc</span></code> subcommand you can add OpenID Connect
credentials to the config:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth add-oidc https://openeo.example.com/
Using provider ID &#39;example&#39; (issuer &#39;https://oidc.example.com/&#39;)
Enter client_id and press enter: client-d7393fba
Enter client_secret and press enter:
Saved client information to &#39;/home/john/.config/openeo-python-client/auth-config.json&#39;
</pre></div>
</div>
<p>Now you can user OpenID Connect based authentication in your application
without having to specify the client ID and client secret explicitly,
like one of these calls:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_client_credentials</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_resource_owner_password_credentials</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_device</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_refresh_token</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that you still have to add additional options as required, like
<code class="docutils literal notranslate"><span class="pre">provider_id</span></code>, <code class="docutils literal notranslate"><span class="pre">server_address</span></code>, <code class="docutils literal notranslate"><span class="pre">store_refresh_token</span></code>, etc.</p>
<section id="openid-connect-refresh-tokens">
<span id="oidc-auth-get-refresh-token"></span><h4>OpenID Connect refresh tokens<a class="headerlink" href="#openid-connect-refresh-tokens" title="Permalink to this heading">¶</a></h4>
<p>There is also a <code class="docutils literal notranslate"><span class="pre">oidc-auth</span></code> subcommand to execute an OpenID Connect
authentication flow and store the resulting refresh token.
This is intended to for bootstrapping the environment or system
on which you want to run openEO scripts or applications that use
the Refresh Token Flow for authentication.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth oidc-auth https://openeo.example.com
Using config &#39;/home/john/.config/openeo-python-client/auth-config.json&#39;.
Starting OpenID Connect device flow.
To authenticate: visit https://oidc.example.net/device and enter the user code &#39;Q7ZNsy&#39;.
Authorized successfully.
The OpenID Connect device flow was successful.
Stored refresh token in &#39;/home/john/.local/share/openeo-python-client/refresh-tokens.json&#39;
</pre></div>
</div>
</section>
</section>
</section>
<section id="default-openeo-back-end-url-and-auto-authentication">
<span id="default-url-and-auto-auth"></span><h2>Default openEO back-end URL and auto-authentication<a class="headerlink" href="#default-openeo-back-end-url-and-auto-authentication" title="Permalink to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.0.</span></p>
</div>
<p>If you often use the same openEO back-end URL and authentication scheme,
it can be handy to put these in a configuration file as discussed at <a class="reference internal" href="configuration.html#configuration-files"><span class="std std-ref">Configuration files</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that <a class="reference internal" href="configuration.html#configuration-files"><span class="std std-ref">these general configuration files</span></a> are different
from the auth config files discussed earlier under <a class="reference internal" href="#auth-configuration-files"><span class="std std-ref">Auth config files and openeo-auth helper tool</span></a>.
The latter are for storing authentication related secrets
and are mostly managed automatically (e.g. by the <code class="docutils literal notranslate"><span class="pre">oidc-auth</span></code> helper tool).
The former are not for storing secrets and are usually edited manually.</p>
</div>
<p>For example, to define a default back-end and automatically use OpenID Connect authentication
add these configuration options to the <a class="reference internal" href="configuration.html#configuration-file-locations"><span class="std std-ref">desired configuration file</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Connection</span><span class="p">]</span>
<span class="n">default_backend</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">cloud</span>
<span class="n">default_backend</span><span class="o">.</span><span class="n">auto_authenticate</span> <span class="o">=</span> <span class="n">oidc</span>
</pre></div>
</div>
<p>Getting an authenticated connection is now as simple as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">openeo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="go">Loaded openEO client config from openeo-client-config.ini</span>
<span class="go">Using default back-end URL &#39;openeo.cloud&#39; (from config)</span>
<span class="go">Doing auto-authentication &#39;oidc&#39; (from config)</span>
<span class="go">Authenticated using refresh token.</span>
</pre></div>
</div>
</section>
<section id="authentication-for-long-running-applications-and-non-interactive-contexts">
<h2>Authentication for long-running applications and non-interactive contexts<a class="headerlink" href="#authentication-for-long-running-applications-and-non-interactive-contexts" title="Permalink to this heading">¶</a></h2>
<p>With OpenID Connect authentication, the <em>access token</em>
(which is used in the authentication headers)
is typically short-lived (e.g. couple of minutes or hours).
This practically means that an authenticated connection could expire and become unusable
before a <strong>long-running script or application</strong> finishes its whole workflow.
Luckily, OpenID Connect also includes usage of <em>refresh tokens</em>,
which have a much longer expiry and allow request a new access token
to re-authenticate the connection.
Since version 0.10.1, te openEO Python Client Library will automatically
attempt to re-authenticate a connection when access token expiry is detected
and valid refresh tokens are available.</p>
<p>Likewise, refresh tokens can also be used for authentication in cases
where a script or application is <strong>run automatically in the background on regular basis</strong> (daily, weekly, …).
If there is a non-expired refresh token available, the script can authenticate
without user interaction.</p>
<section id="guidelines-and-tips">
<h3>Guidelines and tips<a class="headerlink" href="#guidelines-and-tips" title="Permalink to this heading">¶</a></h3>
<p>Some guidelines get long-term and non-interactive authentication working for your use case:</p>
<ul>
<li><p>If you run a workflow periodically, but the interval between runs
is larger than the expiry time of the refresh token
(e.g. a monthly job, while the refresh token expires after, say, 10 days),
you could consider setting up a <em>custom OIDC client</em> with better suited
refresh token timeout.
The practical details of this heavily depend on the OIDC Identity Provider
in play and are out of scope of this discussion.</p></li>
<li><p>Obtaining the initial refresh token requires manual/interactive authentication,
but once it is stored on the necessary machine(s)
in the refresh token store as discussed in <a class="reference internal" href="#auth-configuration-files"><span class="std std-ref">Auth config files and openeo-auth helper tool</span></a>,
no further manual interaction should be necessary.
To do so, use one of the following methods:</p>
<ul>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">openeo-auth</span> <span class="pre">oidc-auth</span></code> cli tool, for example to authenticate
for openeo back-end openo.example.com:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth oidc-auth openeo.example.com
...
Stored refresh token in &#39;/home/john/.local/share/openeo-python-client/refresh-tokens.json&#39;
</pre></div>
</div>
</li>
<li><p>Use a Python snippet to authenticate and store the refresh token:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openeo</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;openeo.example.com&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_device</span><span class="p">(</span><span class="n">store_refresh_token</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>To verify that (and where) the refresh token is stored, use <code class="docutils literal notranslate"><span class="pre">openeo-auth</span> <span class="pre">token-dump</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth token-dump
### /home/john/.local/share/openeo-python-client/refresh-tokens.json #######
{
  &quot;https://oidc.example.net&quot;: {
    &quot;default-client&quot;: {
      &quot;date&quot;: &quot;2022-05-11T13:13:20Z&quot;,
      &quot;refresh_token&quot;: &quot;&lt;redacted&gt;&quot;
    },
...
</pre></div>
</div>
</li>
<li><p>Authenticate in your script or application with the refresh token
and make sure newer refresh tokens are stored as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openeo</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;openeo.example.com&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_refresh_token</span><span class="p">(</span><span class="n">store_refresh_token</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="best-practices-and-troubleshooting-tips">
<h2>Best Practices and Troubleshooting Tips<a class="headerlink" href="#best-practices-and-troubleshooting-tips" title="Permalink to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Handle (OIDC) access and refresh tokens like secret, personal passwords.
<strong>Never share your access or refresh tokens</strong> with other people,
publicly, or for user support reasons.</p>
</div>
<section id="clear-the-refresh-token-file">
<h3>Clear the refresh token file<a class="headerlink" href="#clear-the-refresh-token-file" title="Permalink to this heading">¶</a></h3>
<p>When you have authentication or permission issues and you suspect
that your (locally cached) refresh tokens are the culprit:
remove your refresh token file in one of the following ways:</p>
<ul>
<li><p>Locate the file with the <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> command line tool:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth paths
...
openEO OpenID Connect refresh token store: /home/john/.local/share/openeo-python-client/refresh-tokens.json (perms: 0o600, size: 846B)
</pre></div>
</div>
<p>and remove it.
Or, if you know what you are doing: remove the desired section from this JSON file.</p>
</li>
<li><p>Remove it directly with the <code class="docutils literal notranslate"><span class="pre">token-clear</span></code> subcommand of the <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> command line tool:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth token-clear
</pre></div>
</div>
</li>
<li><p>Remove it with this Python snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openeo.rest.auth.config</span> <span class="kn">import</span> <span class="n">RefreshTokenStore</span>
<span class="n">RefreshTokenStore</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">openEO Python Client</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Open-EO&repo=openeo-python-client&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<h3><a href="index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">openEO Python Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_access.html">Finding and loading data</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Working with processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_jobs.html">Batch Jobs</a></li>
<li class="toctree-l1"><a class="reference internal" href="udp.html">User-Defined Processes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Authentication and Account Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-http-auth">Basic HTTP Auth</a></li>
<li class="toctree-l2"><a class="reference internal" href="#openid-connect-based-authentication">OpenID Connect Based Authentication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#auth-config-files-and-openeo-auth-helper-tool">Auth config files and <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> helper tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#default-openeo-back-end-url-and-auto-authentication">Default openEO back-end URL and auto-authentication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#authentication-for-long-running-applications-and-non-interactive-contexts">Authentication for long-running applications and non-interactive contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#best-practices-and-troubleshooting-tips">Best Practices and Troubleshooting Tips</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="udf.html">User-Defined Functions (UDF) explained</a></li>
<li class="toctree-l1"><a class="reference internal" href="datacube_construction.html">DataCube construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_learning.html">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="cookbook/index.html">openEO CookBook</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="process_mapping.html">openEO Process Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development and maintenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="best_practices.html">Best practices, coding style and general tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="udp.html" title="previous chapter">User-Defined Processes</a></li>
      <li>Next: <a href="udf.html" title="next chapter">User-Defined Functions (UDF) explained</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Alabaster (krTheme++) Hacks -->

<div class="sidebar-meta">
<h3>Meta</h3>
<div>Docs for openEO Python Client</div>
<div>Version: <code>0.12.0a1</code></div>
<div>Last updated: 2022/08/26</div>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017 - 2022, Jeroen Dries.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/auth.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/Open-EO/openeo-python-client" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>