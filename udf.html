
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>User-Defined Functions (UDF) explained &#8212; openEO Python Client 0.12.0a1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="DataCube construction" href="datacube_construction.html" />
    <link rel="prev" title="Authentication and Account Management" href="auth.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <span class="target" id="index-0"></span><section id="user-defined-functions-udf-explained">
<span id="user-defined-functions"></span><span id="index-1"></span><h1>User-Defined Functions (UDF) explained<a class="headerlink" href="#user-defined-functions-udf-explained" title="Permalink to this heading">¶</a></h1>
<p>While openEO supports a wide range of pre-defined processes
and allows to build more complex user-defined processes from them,
you sometimes need operations or algorithms that are
not (yet) available or standardized as openEO process.
<strong>User-Defined Functions (UDF)</strong> is an openEO feature
(through the <a class="reference external" href="https://processes.openeo.org/#run_udf">run_udf</a> process)
that aims to fill that gap by allowing a user to express (a part of)
an <strong>algorithm as a Python/R/… script to be run back-end side</strong>.</p>
<p>Ideally, it allows you to embed existing Python/R/… implementations
in an openEO workflow (with some necessary “glue code”).
However, it is recommended to try to do as much pre- or postprocessing
with pre-defined processes
before blindly copy-pasting source code snippets as UDFs.
Pre-defined processes are typically well-optimized by the backend,
while UDFs can come with a performance penalty
and higher development/debug/maintenance costs.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Don not confuse <strong>user-defined functions</strong> (abbreviated as UDF) with
<strong>user-defined processes</strong> (sometimes abbreviated as UDP) in openEO,
which is a way to define and use your own process graphs
as reusable building blocks.
See <a class="reference internal" href="udp.html#user-defined-processes"><span class="std std-ref">User-Defined Processes</span></a> for more information.</p>
</div>
<section id="applicability-and-constraints">
<h2>Applicability and Constraints<a class="headerlink" href="#applicability-and-constraints" title="Permalink to this heading">¶</a></h2>
<p id="index-2">openEO is designed to work transparently on large data sets
and your UDF has to follow a couple of guidelines to make that possible.
First of all, as data cubes play a central role in openEO,
your UDF should accept and return correct <strong>data cube structures</strong>,
with proper dimensions, dimension labels, etc.
Moreover, the back-end will typically divide your input data cube
in smaller chunks and process these chunks separately (e.g. on isolated workers).
Consequently, it’s important that your <strong>UDF algorithm operates correctly
in such a chunked processing context</strong>.</p>
<section id="udfs-as-apply-reduce-callbacks">
<h3>UDFs as apply/reduce “callbacks”<a class="headerlink" href="#udfs-as-apply-reduce-callbacks" title="Permalink to this heading">¶</a></h3>
<p>UDFs are typically used as “callback” processes for “meta” processes
like <code class="docutils literal notranslate"><span class="pre">apply</span></code> or <code class="docutils literal notranslate"><span class="pre">reduce_dimension</span></code> (also see <a class="reference internal" href="processes.html#callbackfunctions"><span class="std std-ref">Processes with child “callbacks”</span></a>).
These meta-processes make abstraction of a datacube as a whole
and allow the callback to focus on a small slice of data or a single dimension.
Their nature instructs the backend how the data should be processed
and can be chunked:</p>
<dl class="simple">
<dt><a class="reference external" href="https://processes.openeo.org/#apply">apply</a></dt><dd><p>Applies a process on <em>each pixel separately</em>.
The back-end has all freedom to choose chunking
(e.g. chunk spatially and temporally).
Dimensions and their labels are fully preserved.
See <a class="reference internal" href="#udf-example-apply"><span class="std std-ref">A first example: apply with an UDF to rescale pixel values</span></a></p>
</dd>
<dt><a class="reference external" href="https://processes.openeo.org/#apply_dimension">apply_dimension</a></dt><dd><p>Applies a process to all pixels <em>along a given dimension</em>
to produce a new series of values for that dimension.
The back-end will not split your data on that dimension.
For example, when working along the time dimension,
your UDF is guaranteed to receive a full timeseries,
but the data could be chunked spatially.
All dimensions and labels are preserved,
except for the dimension along which <code class="docutils literal notranslate"><span class="pre">apply_dimension</span></code> is applied:
the number of dimension labels is allowed to change.</p>
</dd>
<dt><a class="reference external" href="https://processes.openeo.org/#reduce_dimension">reduce_dimension</a></dt><dd><p>Applies a process to all pixels <em>along a given dimension</em>
to produce a single value, eliminating that dimension.
Like with <code class="docutils literal notranslate"><span class="pre">apply_dimension</span></code>, the back-end will
not split your data on that dimension.
The dimension along which <code class="docutils literal notranslate"><span class="pre">apply_dimension</span></code> is applied must be removed
from the output.
For example, when applying <code class="docutils literal notranslate"><span class="pre">reduce_dimension</span></code> on a spatiotemporal cube
along the time dimension,
the UDF is guaranteed to receive full timeseries
(but the data could be chunked spatially)
and the output cube should only be a spatial cube, without a temporal dimension</p>
</dd>
<dt><a class="reference external" href="https://processes.openeo.org/#apply_neighborhood">apply_neighborhood</a></dt><dd><p>Applies a process to a neighborhood of pixels
in a sliding-window fashion with (optional) overlap.
Data chunking in this case is explicitly controlled by the user.
Dimensions and number of labels are fully preserved.</p>
</dd>
</dl>
</section>
</section>
<section id="udf-function-names-and-signatures">
<h2>UDF function names and signatures<a class="headerlink" href="#udf-function-names-and-signatures" title="Permalink to this heading">¶</a></h2>
<p>The UDF code you pass to the back-end is basically a Python script
that contains one or more functions.
Exactly one of these functions should have a proper UDF signature,
as defined in the <a class="reference internal" href="#module-openeo.udf.udf_signatures" title="openeo.udf.udf_signatures"><code class="xref py py-mod docutils literal notranslate"><span class="pre">openeo.udf.udf_signatures</span></code></a> module,
so that the back-end knows what the <em>entrypoint</em> function is
of your UDF implementation.</p>
<section id="module-openeo.udf.udf_signatures">
<span id="module-openeo-udf-udf-signatures"></span><h3>Module <code class="docutils literal notranslate"><span class="pre">openeo.udf.udf_signatures</span></code><a class="headerlink" href="#module-openeo.udf.udf_signatures" title="Permalink to this heading">¶</a></h3>
<p>This module defines a number of function signatures that can be implemented by UDF’s.
Both the name of the function and the argument types are/can be used by the backend to validate if the provided UDF
is compatible with the calling context of the process graph in which it is used.</p>
<dl class="py function">
<dt class="sig sig-object py" id="openeo.udf.udf_signatures.apply_datacube">
<span class="sig-prename descclassname"><span class="pre">openeo.udf.udf_signatures.</span></span><span class="sig-name descname"><span class="pre">apply_datacube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/openeo/udf/udf_signatures.html#apply_datacube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#openeo.udf.udf_signatures.apply_datacube" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a <code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code> to another <code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code>.</p>
<p>Depending on the context in which this function is used, the <code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code> dimensions
have to be retained or can be chained.
For instance, in the context of a reducing operation along a dimension,
that dimension will have to be reduced to a single value.
In the context of a 1 to 1 mapping operation, all dimensions have to be retained.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cube</strong> (<a class="reference internal" href="api.html#openeo.udf.xarraydatacube.XarrayDataCube" title="openeo.udf.xarraydatacube.XarrayDataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code></a>) – input data cube</p></li>
<li><p><strong>context</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing user context.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="api.html#openeo.udf.xarraydatacube.XarrayDataCube" title="openeo.udf.xarraydatacube.XarrayDataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code></a></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>output data cube</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openeo.udf.udf_signatures.apply_timeseries">
<span class="sig-prename descclassname"><span class="pre">openeo.udf.udf_signatures.</span></span><span class="sig-name descname"><span class="pre">apply_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/openeo/udf/udf_signatures.html#apply_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#openeo.udf.udf_signatures.apply_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a timeseries of values, without changing the time instants.</p>
<p>This can for instance be used for smoothing or gap-filling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>series</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>) – A Pandas Series object with a date-time index.</p></li>
<li><p><strong>context</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing user context.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Pandas Series object with the same datetime index.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="openeo.udf.udf_signatures.apply_udf_data">
<span class="sig-prename descclassname"><span class="pre">openeo.udf.udf_signatures.</span></span><span class="sig-name descname"><span class="pre">apply_udf_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/openeo/udf/udf_signatures.html#apply_udf_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#openeo.udf.udf_signatures.apply_udf_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic UDF function that directly manipulates a <code class="xref py py-class docutils literal notranslate"><span class="pre">UdfData</span></code> object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<a class="reference internal" href="api.html#openeo.udf.udf_data.UdfData" title="openeo.udf.udf_data.UdfData"><code class="xref py py-class docutils literal notranslate"><span class="pre">UdfData</span></code></a>) – <code class="xref py py-class docutils literal notranslate"><span class="pre">UdfData</span></code> object to manipulate in-place</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="a-first-example-apply-with-an-udf-to-rescale-pixel-values">
<span id="udf-example-apply"></span><h2>A first example: <code class="docutils literal notranslate"><span class="pre">apply</span></code> with an UDF to rescale pixel values<a class="headerlink" href="#a-first-example-apply-with-an-udf-to-rescale-pixel-values" title="Permalink to this heading">¶</a></h2>
<p>In most of the examples here, we will start from an initial Sentinel2 data cube like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s2_cube</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">load_collection</span><span class="p">(</span>
    <span class="s2">&quot;SENTINEL2_L2A&quot;</span><span class="p">,</span>
    <span class="n">spatial_extent</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;west&quot;</span><span class="p">:</span> <span class="mf">4.00</span><span class="p">,</span> <span class="s2">&quot;south&quot;</span><span class="p">:</span> <span class="mf">51.04</span><span class="p">,</span> <span class="s2">&quot;east&quot;</span><span class="p">:</span> <span class="mf">4.10</span><span class="p">,</span> <span class="s2">&quot;north&quot;</span><span class="p">:</span> <span class="mf">51.1</span><span class="p">},</span>
    <span class="n">temporal_extent</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;2022-03-01&quot;</span><span class="p">,</span> <span class="s2">&quot;2022-03-31&quot;</span><span class="p">],</span>
    <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;B02&quot;</span><span class="p">,</span> <span class="s2">&quot;B03&quot;</span><span class="p">,</span> <span class="s2">&quot;B04&quot;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The raw values in this initial <code class="docutils literal notranslate"><span class="pre">s2_cube</span></code> data cube are <strong>digital numbers</strong>
(integer values ranging from 0 to several thousands)
and to get <strong>physical reflectance</strong> values (float values, typically in the range between 0 and 0.5),
we have to rescale them.
This is a simple local transformation, without any interaction between pixels,
which is the modus operandi of the <code class="docutils literal notranslate"><span class="pre">apply</span></code> processes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In practice it will be a lot easier and more efficient to do this kind of rescaling
with pre-defined openEO math processes, for example: <code class="docutils literal notranslate"><span class="pre">s2_cube.apply(lambda</span> <span class="pre">x:</span> <span class="pre">0.0001</span> <span class="pre">*</span> <span class="pre">x)</span></code>.
This is just a very simple illustration to get started with UDFs.</p>
</div>
<section id="udf-script">
<h3>UDF script<a class="headerlink" href="#udf-script" title="Permalink to this heading">¶</a></h3>
<p>The UDF code is this short script (the part that does the actual value rescaling is highlighted):</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">udf-code.py</span></code></span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kn">from</span> <span class="nn">openeo.udf</span> <span class="kn">import</span> <span class="n">XarrayDataCube</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="k">def</span> <span class="nf">apply_datacube</span><span class="p">(</span><span class="n">cube</span><span class="p">:</span> <span class="n">XarrayDataCube</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XarrayDataCube</span><span class="p">:</span>
<span class="linenos">4</span>    <span class="n">array</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
<span class="hll"><span class="linenos">5</span>    <span class="n">array</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="mf">0.0001</span> <span class="o">*</span> <span class="n">array</span><span class="o">.</span><span class="n">values</span>
</span><span class="linenos">6</span>    <span class="k">return</span> <span class="n">cube</span>
</pre></div>
</div>
</div>
<p>Some details about this UDF script:</p>
<ul class="simple">
<li><p>line 1: We import <a class="reference internal" href="api.html#openeo.udf.xarraydatacube.XarrayDataCube" title="openeo.udf.xarraydatacube.XarrayDataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code></a> to use as type annotation of the UDF function.</p></li>
<li><p>line 3: We define a function named <code class="docutils literal notranslate"><span class="pre">apply_datacube</span></code>,
which receives and returns a <a class="reference internal" href="api.html#openeo.udf.xarraydatacube.XarrayDataCube" title="openeo.udf.xarraydatacube.XarrayDataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code></a> instance.
We follow here the <a class="reference internal" href="#openeo.udf.udf_signatures.apply_datacube" title="openeo.udf.udf_signatures.apply_datacube"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_datacube()</span></code></a> UDF function signature.</p></li>
<li><p>line 4: <code class="docutils literal notranslate"><span class="pre">cube</span></code> (a <a class="reference internal" href="api.html#openeo.udf.xarraydatacube.XarrayDataCube" title="openeo.udf.xarraydatacube.XarrayDataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code></a> object) is a thin wrapper
around the data of the chunk we are currently processing.
We use <a class="reference internal" href="api.html#openeo.udf.xarraydatacube.XarrayDataCube.get_array" title="openeo.udf.xarraydatacube.XarrayDataCube.get_array"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_array()</span></code></a> to get this data,
which is an <code class="docutils literal notranslate"><span class="pre">xarray.DataArray</span></code> object.</p></li>
<li><p>line 5: Because our scaling operation is so simple, we can transform the <code class="docutils literal notranslate"><span class="pre">xarray.DataArray</span></code> values in-place.</p></li>
<li><p>line 6: Consequently, because the values were updated in-place,
we don’t have to build a new <a class="reference internal" href="api.html#openeo.udf.xarraydatacube.XarrayDataCube" title="openeo.udf.xarraydatacube.XarrayDataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">XarrayDataCube</span></code></a> object
and can just return the (in-place updated) <code class="docutils literal notranslate"><span class="pre">cube</span></code> object again.</p></li>
</ul>
</section>
<section id="workflow-script">
<h3>Workflow script<a class="headerlink" href="#workflow-script" title="Permalink to this heading">¶</a></h3>
<p>In this first example, we’ll cite a full, standalone openEO workflow script,
including creating the back-end connection, loading the initial data cube and downloading the result.
The UDF-specific part is highlighted:</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">UDF usage example snippet</span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kn">import</span> <span class="nn">openeo</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="c1"># Create connection to openEO back-end</span>
<span class="linenos"> 4</span><span class="n">connection</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">authenticate_oidc</span><span class="p">()</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="c1"># Load initial data cube.</span>
<span class="linenos"> 7</span><span class="n">s2_cube</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">load_collection</span><span class="p">(</span>
<span class="linenos"> 8</span>    <span class="s2">&quot;SENTINEL2_L2A&quot;</span><span class="p">,</span>
<span class="linenos"> 9</span>    <span class="n">spatial_extent</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;west&quot;</span><span class="p">:</span> <span class="mf">4.00</span><span class="p">,</span> <span class="s2">&quot;south&quot;</span><span class="p">:</span> <span class="mf">51.04</span><span class="p">,</span> <span class="s2">&quot;east&quot;</span><span class="p">:</span> <span class="mf">4.10</span><span class="p">,</span> <span class="s2">&quot;north&quot;</span><span class="p">:</span> <span class="mf">51.1</span><span class="p">},</span>
<span class="linenos">10</span>    <span class="n">temporal_extent</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;2022-03-01&quot;</span><span class="p">,</span> <span class="s2">&quot;2022-03-31&quot;</span><span class="p">],</span>
<span class="linenos">11</span>    <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;B02&quot;</span><span class="p">,</span> <span class="s2">&quot;B03&quot;</span><span class="p">,</span> <span class="s2">&quot;B04&quot;</span><span class="p">]</span>
<span class="linenos">12</span><span class="p">)</span>
<span class="linenos">13</span>
<span class="hll"><span class="linenos">14</span><span class="c1"># UDF code (as inline string)</span>
</span><span class="hll"><span class="linenos">15</span><span class="n">udf_code</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="linenos">16</span><span class="s2">from openeo.udf import XarrayDataCube</span>
</span><span class="hll"><span class="linenos">17</span>
</span><span class="hll"><span class="linenos">18</span><span class="s2">def apply_datacube(cube: XarrayDataCube, context: dict) -&gt; XarrayDataCube:</span>
</span><span class="hll"><span class="linenos">19</span><span class="s2">    array = cube.get_array()</span>
</span><span class="hll"><span class="linenos">20</span><span class="s2">    array.values = 0.0001 * array.values</span>
</span><span class="hll"><span class="linenos">21</span><span class="s2">    return cube</span>
</span><span class="hll"><span class="linenos">22</span><span class="s2">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="linenos">23</span>
</span><span class="hll"><span class="linenos">24</span><span class="c1"># Create UDF helper object encapsulating the UDF code.</span>
</span><span class="hll"><span class="linenos">25</span><span class="n">udf</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">UDF</span><span class="p">(</span><span class="n">code</span><span class="o">=</span><span class="n">udf_code</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">})</span>
</span><span class="hll"><span class="linenos">26</span>
</span><span class="hll"><span class="linenos">27</span><span class="c1"># Pass UDF object as child process to `apply`.</span>
</span><span class="hll"><span class="linenos">28</span><span class="n">rescaled</span> <span class="o">=</span> <span class="n">s2_cube</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">process</span><span class="o">=</span><span class="n">udf</span><span class="p">)</span>
</span><span class="linenos">29</span>
<span class="linenos">30</span><span class="n">rescaled</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="s2">&quot;apply-udf-scaling.nc&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Discussion:</p>
<ul class="simple">
<li><p>Line 15: We define the UDF code as an inline string.</p></li>
<li><p>Line 25: <code class="xref py py-class docutils literal notranslate"><span class="pre">openeo.UDF</span></code> is a helper class to build a <code class="docutils literal notranslate"><span class="pre">run_udf</span></code> node,
to be used as child process in the <code class="docutils literal notranslate"><span class="pre">apply</span></code> process.</p></li>
<li><p>Line 28: we pass this UDF object as the <code class="docutils literal notranslate"><span class="pre">process</span></code> argument
to <a class="reference internal" href="api.html#openeo.rest.datacube.DataCube.apply" title="openeo.rest.datacube.DataCube.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataCube.apply()</span></code></a></p></li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Instead of putting your UDF code in an inline string like in the example,
it’s usually recommended to <strong>load the UDF code from a separate file</strong>,
which is easier to maintain in your preferred editor or IDE.
For example, using the handy <code class="docutils literal notranslate"><span class="pre">pathlib</span></code> module from Python’s standard library:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">udf_code</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;udf-code.py&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read_text</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>After downloading the result, we can inspect the band values locally.
Note see that they fall mainly in a range from 0 to 1 (in most cases even below 0.2),
instead of the original digital number range (thousands):</p>
<img alt="_images/apply-rescaled-histogram.png" src="_images/apply-rescaled-histogram.png" />
</section>
</section>
<section id="illustration-of-data-chunking-in-apply-with-a-udf">
<h2>Illustration of data chunking in <code class="docutils literal notranslate"><span class="pre">apply</span></code> with a  UDF<a class="headerlink" href="#illustration-of-data-chunking-in-apply-with-a-udf" title="Permalink to this heading">¶</a></h2>
<p>TODO</p>
</section>
<section id="example-apply-dimension-with-a-udf">
<h2>Example: <code class="docutils literal notranslate"><span class="pre">apply_dimension</span></code> with a UDF<a class="headerlink" href="#example-apply-dimension-with-a-udf" title="Permalink to this heading">¶</a></h2>
<p>TODO</p>
</section>
<section id="example-reduce-dimension-with-a-udf">
<h2>Example: <code class="docutils literal notranslate"><span class="pre">reduce_dimension</span></code> with a UDF<a class="headerlink" href="#example-reduce-dimension-with-a-udf" title="Permalink to this heading">¶</a></h2>
<p>TODO</p>
</section>
<section id="example-apply-neighborhood-with-a-udf">
<h2>Example: <code class="docutils literal notranslate"><span class="pre">apply_neighborhood</span></code> with a UDF<a class="headerlink" href="#example-apply-neighborhood-with-a-udf" title="Permalink to this heading">¶</a></h2>
<p>TODO</p>
</section>
<section id="example-smoothing-timeseries-with-a-user-defined-function-udf">
<h2>Example: Smoothing timeseries with a user defined function (UDF)<a class="headerlink" href="#example-smoothing-timeseries-with-a-user-defined-function-udf" title="Permalink to this heading">¶</a></h2>
<p>In this example, we start from the <code class="docutils literal notranslate"><span class="pre">evi_cube</span></code> that was created in the previous example, and want to
apply a temporal smoothing on it. More specifically, we want to use the “Savitzky Golay” smoother
that is available in the SciPy Python library.</p>
<p>To ensure that openEO understand your function, it needs to follow some rules, the UDF specification.
This is an example that follows those rules:</p>
<div class="literal-block-wrapper docutils container" id="savgol-udf">
<div class="code-block-caption"><span class="caption-text">Example UDF code <code class="docutils literal notranslate"><span class="pre">smooth_savitzky_golay.py</span></code></span><a class="headerlink" href="#savgol-udf" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xarray</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>

<span class="kn">from</span> <span class="nn">openeo.udf</span> <span class="kn">import</span> <span class="n">XarrayDataCube</span>


<span class="k">def</span> <span class="nf">apply_datacube</span><span class="p">(</span><span class="n">cube</span><span class="p">:</span> <span class="n">XarrayDataCube</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XarrayDataCube</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply Savitzky-Golay smoothing to a timeseries datacube.</span>
<span class="sd">    This UDF preserves dimensionality, and assumes an input</span>
<span class="sd">    datacube with a temporal dimension &#39;t&#39; as input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array</span><span class="p">:</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
    <span class="n">filled</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">interpolate_na</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">smoothed_array</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">filled</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">XarrayDataCube</span><span class="p">(</span>
        <span class="n">array</span><span class="o">=</span><span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">smoothed_array</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
<p>The method signature of the UDF is very important, because the back-end will use it to detect
the type of UDF.
This particular example accepts a <a class="reference internal" href="api.html#openeo.rest.datacube.DataCube" title="openeo.rest.datacube.DataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCube</span></code></a> object as input and also returns a <a class="reference internal" href="api.html#openeo.rest.datacube.DataCube" title="openeo.rest.datacube.DataCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCube</span></code></a> object.
The type annotations and method name are actually used to detect how to invoke the UDF, so make sure they remain unchanged.</p>
<p>Once the UDF is defined in a separate file, we need to load it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">smoothing_udf</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;smooth_savitzky_golay.py&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">smoothing_udf</span><span class="p">)</span>
</pre></div>
</div>
<p>after that, we can simply apply it along a dimension:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">smoothed_evi</span> <span class="o">=</span> <span class="n">evi_cube_masked</span><span class="o">.</span><span class="n">apply_dimension</span><span class="p">(</span>
    <span class="n">code</span><span class="o">=</span><span class="n">smoothing_udf</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="s1">&#39;Python&#39;</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="s2">&quot;t&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="downloading-a-datacube-and-executing-an-udf-locally">
<h2>Downloading a datacube and executing an UDF locally<a class="headerlink" href="#downloading-a-datacube-and-executing-an-udf-locally" title="Permalink to this heading">¶</a></h2>
<p>Sometimes it is advantageous to run a UDF on the client machine (for example when developing/testing that UDF).
This is possible by using the convenience function <a class="reference internal" href="api.html#openeo.udf.run_code.execute_local_udf" title="openeo.udf.run_code.execute_local_udf"><code class="xref py py-func docutils literal notranslate"><span class="pre">openeo.udf.run_code.execute_local_udf()</span></code></a>.
The steps to run a UDF (like the code from <code class="docutils literal notranslate"><span class="pre">smooth_savitzky_golay.py</span></code> above) are as follows:</p>
<ul class="simple">
<li><p>Run the processes (or process graph) preceding the UDF and download the result in ‘NetCDF’ or ‘JSON’ format.</p></li>
<li><p>Run <a class="reference internal" href="api.html#openeo.udf.run_code.execute_local_udf" title="openeo.udf.run_code.execute_local_udf"><code class="xref py py-func docutils literal notranslate"><span class="pre">openeo.udf.run_code.execute_local_udf()</span></code></a> on the data file.</p></li>
</ul>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">openeo.udf</span> <span class="kn">import</span> <span class="n">execute_local_udf</span>

<span class="n">my_process</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">load_collection</span><span class="p">(</span><span class="o">...</span>

<span class="n">my_process</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="s1">&#39;test_input.nc&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NetCDF&#39;</span><span class="p">)</span>

<span class="n">smoothing_udf</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;smooth_savitzky_golay.py&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span>
<span class="n">execute_local_udf</span><span class="p">(</span><span class="n">smoothing_udf</span><span class="p">,</span> <span class="s1">&#39;test_input.nc&#39;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;netcdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: this algorithm’s primary purpose is to aid client side development of UDFs using small datasets. It is not designed for large jobs.</p>
</section>
<section id="profile-a-process-server-side">
<h2>Profile a process server-side<a class="headerlink" href="#profile-a-process-server-side" title="Permalink to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Experimental feature - This feature only works on back-ends running the Geotrellis implementation, and has not yet been
adopted in the openEO API.</p>
</div>
<p>Sometimes users want to ‘profile’ their UDF on the back-end. While it’s recommended to first profile it offline, in the
same manner as you can debug UDF’s, back-ends may support profiling directly.
Note that this will only generate statistics over the python part of the execution, therefore it is only suitable for profiling UDFs.</p>
<section id="usage">
<h3>Usage<a class="headerlink" href="#usage" title="Permalink to this heading">¶</a></h3>
<p>Only batch jobs are supported! In order to turn on profiling, set ‘profile’ to ‘true’ in job options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">job_options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;profile&#39;</span><span class="p">:</span><span class="s1">&#39;true&#39;</span><span class="p">}</span>
<span class="o">...</span> <span class="c1"># prepare the process</span>
<span class="n">process</span><span class="o">.</span><span class="n">execute_batch</span><span class="p">(</span><span class="s1">&#39;result.tif&#39;</span><span class="p">,</span><span class="n">job_options</span><span class="o">=</span><span class="n">job_options</span><span class="p">)</span>
</pre></div>
</div>
<p>When the process has finished, it will also download a file called ‘profile_dumps.tar.gz’:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rdd_-1.pstats</span></code> is the profile data of the python driver,</p></li>
<li><p>the rest are the profiling results of the individual rdd id-s (that can be correlated with the execution using the SPARK UI).</p></li>
</ul>
</section>
<section id="viewing-profiling-information">
<h3>Viewing profiling information<a class="headerlink" href="#viewing-profiling-information" title="Permalink to this heading">¶</a></h3>
<p>The simplest way is to visualize the results with a graphical visualization tool called kcachegrind.
In order to do that, install <a class="reference external" href="http://kcachegrind.sourceforge.net/">kcachegrind</a> packages (most linux distributions have it installed by default) and it’s python connector <a class="reference external" href="https://pypi.org/project/pyprof2calltree/">pyprof2calltree</a>.
From command line run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyprof2calltree</span> <span class="n">rdd_</span><span class="o">&lt;</span><span class="n">INTERESTING_RDD_ID</span><span class="o">&gt;.</span><span class="n">pstats</span><span class="o">.</span>
</pre></div>
</div>
<p>Another way is to use the builtin pstats functionality from within python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pstats</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="s1">&#39;restats&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this heading">¶</a></h3>
<p>An example code can be found <a class="reference external" href="https://github.com/Open-EO/openeo-python-client/tree/master/examples/profiling_example.py">here</a> .</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">openEO Python Client</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Open-EO&repo=openeo-python-client&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<h3><a href="index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">openEO Python Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_access.html">Finding and loading data</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Working with processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="batch_jobs.html">Batch Jobs</a></li>
<li class="toctree-l1"><a class="reference internal" href="udp.html">User-Defined Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="auth.html">Authentication and Account Management</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">User-Defined Functions (UDF) explained</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#applicability-and-constraints">Applicability and Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#udf-function-names-and-signatures">UDF function names and signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-first-example-apply-with-an-udf-to-rescale-pixel-values">A first example: <code class="docutils literal notranslate"><span class="pre">apply</span></code> with an UDF to rescale pixel values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#illustration-of-data-chunking-in-apply-with-a-udf">Illustration of data chunking in <code class="docutils literal notranslate"><span class="pre">apply</span></code> with a  UDF</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-apply-dimension-with-a-udf">Example: <code class="docutils literal notranslate"><span class="pre">apply_dimension</span></code> with a UDF</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-reduce-dimension-with-a-udf">Example: <code class="docutils literal notranslate"><span class="pre">reduce_dimension</span></code> with a UDF</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-apply-neighborhood-with-a-udf">Example: <code class="docutils literal notranslate"><span class="pre">apply_neighborhood</span></code> with a UDF</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-smoothing-timeseries-with-a-user-defined-function-udf">Example: Smoothing timeseries with a user defined function (UDF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#downloading-a-datacube-and-executing-an-udf-locally">Downloading a datacube and executing an UDF locally</a></li>
<li class="toctree-l2"><a class="reference internal" href="#profile-a-process-server-side">Profile a process server-side</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="datacube_construction.html">DataCube construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_learning.html">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="cookbook/index.html">openEO CookBook</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="process_mapping.html">openEO Process Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development and maintenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="best_practices.html">Best practices, coding style and general tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="auth.html" title="previous chapter">Authentication and Account Management</a></li>
      <li>Next: <a href="datacube_construction.html" title="next chapter">DataCube construction</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Alabaster (krTheme++) Hacks -->

<div class="sidebar-meta">
<h3>Meta</h3>
<div>Docs for openEO Python Client</div>
<div>Version: <code>0.12.0a1</code></div>
<div>Last updated: 2022/08/26</div>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017 - 2022, Jeroen Dries.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/udf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/Open-EO/openeo-python-client" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>