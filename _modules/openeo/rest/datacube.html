
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>openeo.rest.datacube &#8212; openEO Python Client 0.12.0a1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for openeo.rest.datacube</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The main module for creating earth observation processes. It aims to easily build complex process chains, that can</span>
<span class="sd">be evaluated by an openEO backend.</span>

<span class="sd">.. data:: THIS</span>

<span class="sd">    Symbolic reference to the current data cube, to be used as argument in :py:meth:`DataCube.process()` calls</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">staticmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span>
<span class="kn">import</span> <span class="nn">shapely.geometry.base</span>
<span class="kn">from</span> <span class="nn">deprecated.sphinx</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">mapping</span>

<span class="kn">import</span> <span class="nn">openeo</span>
<span class="kn">import</span> <span class="nn">openeo.processes</span>
<span class="kn">from</span> <span class="nn">openeo.api.process</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">openeo.internal.documentation</span> <span class="kn">import</span> <span class="n">openeo_process</span>
<span class="kn">from</span> <span class="nn">openeo.internal.graph_building</span> <span class="kn">import</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">ReduceNode</span><span class="p">,</span> <span class="n">_FromNodeMixin</span>
<span class="kn">from</span> <span class="nn">openeo.internal.processes.builder</span> <span class="kn">import</span> <span class="n">get_parameter_names</span><span class="p">,</span> <span class="n">convert_callable_to_pgnode</span>
<span class="kn">from</span> <span class="nn">openeo.metadata</span> <span class="kn">import</span> <span class="n">CollectionMetadata</span><span class="p">,</span> <span class="n">Band</span><span class="p">,</span> <span class="n">BandDimension</span>
<span class="kn">from</span> <span class="nn">openeo.processes</span> <span class="kn">import</span> <span class="n">ProcessBuilder</span>
<span class="kn">from</span> <span class="nn">openeo.rest</span> <span class="kn">import</span> <span class="n">BandMathException</span><span class="p">,</span> <span class="n">OperatorException</span><span class="p">,</span> <span class="n">OpenEoClientException</span>
<span class="kn">from</span> <span class="nn">openeo.rest._datacube</span> <span class="kn">import</span> <span class="n">_ProcessGraphAbstraction</span><span class="p">,</span> <span class="n">THIS</span>
<span class="kn">from</span> <span class="nn">openeo.rest.job</span> <span class="kn">import</span> <span class="n">BatchJob</span><span class="p">,</span> <span class="n">RESTJob</span>
<span class="kn">from</span> <span class="nn">openeo.rest.mlmodel</span> <span class="kn">import</span> <span class="n">MlModel</span>
<span class="kn">from</span> <span class="nn">openeo.rest.service</span> <span class="kn">import</span> <span class="n">Service</span>
<span class="kn">from</span> <span class="nn">openeo.rest.udp</span> <span class="kn">import</span> <span class="n">RESTUserDefinedProcess</span>
<span class="kn">from</span> <span class="nn">openeo.rest.vectorcube</span> <span class="kn">import</span> <span class="n">VectorCube</span>
<span class="kn">from</span> <span class="nn">openeo.util</span> <span class="kn">import</span> <span class="n">get_temporal_extent</span><span class="p">,</span> <span class="n">dict_no_none</span><span class="p">,</span> <span class="n">legacy_alias</span><span class="p">,</span> <span class="n">rfc3339</span><span class="p">,</span> <span class="n">guess_format</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># Imports for type checking only (circular import issue at runtime).</span>
    <span class="kn">from</span> <span class="nn">openeo.rest.connection</span> <span class="kn">import</span> <span class="n">Connection</span>
    <span class="kn">import</span> <span class="nn">xarray</span>
    <span class="kn">from</span> <span class="nn">openeo.udf</span> <span class="kn">import</span> <span class="n">XarrayDataCube</span>


<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="DataCube"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube">[docs]</a><span class="k">class</span> <span class="nc">DataCube</span><span class="p">(</span><span class="n">_ProcessGraphAbstraction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing a openEO (raster) data cube.</span>

<span class="sd">    The data cube is represented by its corresponding openeo &quot;process graph&quot;</span>
<span class="sd">    and this process graph can be &quot;grown&quot; to a desired workflow by calling the appropriate methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">connection</span><span class="p">:</span> <span class="s1">&#39;openeo.Connection&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">CollectionMetadata</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pgnode</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>  <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">CollectionMetadata</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.process"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">process_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CollectionMetadata</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">namespace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic helper to create a new DataCube by applying a process.</span>

<span class="sd">        :param process_id: process id of the process.</span>
<span class="sd">        :param arguments: argument dictionary for the process.</span>
<span class="sd">        :param metadata: optional: metadata to override original cube metadata (e.g. when reducing dimensions)</span>
<span class="sd">        :param namespace: optional: process namespace</span>
<span class="sd">        :return: new DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_pgnode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="n">process_id</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DataCube</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

    <span class="n">graph_add_node</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="s2">&quot;graph_add_node&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.process_with_node"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.process_with_node">[docs]</a>    <span class="k">def</span> <span class="nf">process_with_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pg</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CollectionMetadata</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic helper to create a new DataCube by applying a process (given as process graph node)</span>

<span class="sd">        :param pg: process graph node (containing process id and arguments)</span>
<span class="sd">        :param metadata: optional: metadata to override original cube metadata (e.g. when reducing dimensions)</span>
<span class="sd">        :return: new DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: deep copy `self.metadata` instead of using same instance?</span>
        <span class="c1"># TODO: cover more cases where metadata has to be altered</span>
        <span class="c1"># TODO: deprecate `process_with_node``: little added value over just calling DataCube() directly</span>
        <span class="k">return</span> <span class="n">DataCube</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.load_collection"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.load_collection">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">load_collection</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">collection_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">connection</span><span class="p">:</span> <span class="s1">&#39;openeo.Connection&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">spatial_extent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">temporal_extent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">,</span><span class="n">PGNode</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">bands</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">fetch_metadata</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Raster Data cube.</span>

<span class="sd">        :param collection_id: image collection identifier</span>
<span class="sd">        :param connection: The connection to use to connect with the backend.</span>
<span class="sd">        :param spatial_extent: limit data to specified bounding box or polygons</span>
<span class="sd">        :param temporal_extent: limit data to specified temporal interval</span>
<span class="sd">        :param bands: only add the specified bands</span>
<span class="sd">        :param properties: limit data by metadata property predicates</span>
<span class="sd">        :return: new DataCube containing the collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">temporal_extent</span><span class="p">:</span>
            <span class="n">temporal_extent</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_temporal_extent</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="n">temporal_extent</span><span class="p">)</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">collection_id</span><span class="p">,</span>
            <span class="c1"># TODO: spatial_extent could also be a &quot;geojson&quot; subtype object, so we might want to allow (and convert) shapely shapes as well here.</span>
            <span class="s1">&#39;spatial_extent&#39;</span><span class="p">:</span> <span class="n">spatial_extent</span><span class="p">,</span>
            <span class="s1">&#39;temporal_extent&#39;</span><span class="p">:</span> <span class="n">temporal_extent</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection_id</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">fetch_metadata</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">collection_metadata</span><span class="p">(</span><span class="n">collection_id</span><span class="p">)</span> <span class="k">if</span> <span class="n">fetch_metadata</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">bands</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="n">bands</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">metadata</span><span class="p">:</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span> <span class="n">b</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">band_name</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">filter_bands</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ensure minimal metadata with best effort band dimension guess (based on `bands` argument).</span>
                <span class="n">band_dimension</span> <span class="o">=</span> <span class="n">BandDimension</span><span class="p">(</span><span class="s2">&quot;bands&quot;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="n">Band</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">])</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">CollectionMetadata</span><span class="p">({},</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="n">band_dimension</span><span class="p">])</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;bands&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bands</span>
        <span class="k">if</span> <span class="n">properties</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">prop</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;load_collection&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span></div>

    <span class="n">create_collection</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">load_collection</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;create_collection&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.load_disk_collection"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.load_disk_collection">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_disk_collection</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">connection</span><span class="p">:</span> <span class="s1">&#39;openeo.Connection&#39;</span><span class="p">,</span> <span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">glob_pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads image data from disk as a DataCube.</span>

<span class="sd">        :param connection: The connection to use to connect with the backend.</span>
<span class="sd">        :param file_format: the file format, e.g. &#39;GTiff&#39;</span>
<span class="sd">        :param glob_pattern: a glob pattern that matches the files to load from disk</span>
<span class="sd">        :param options: options specific to the file format</span>
<span class="sd">        :return: the data as a DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;load_disk_data&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;format&#39;</span><span class="p">:</span> <span class="n">file_format</span><span class="p">,</span>
                <span class="s1">&#39;glob_pattern&#39;</span><span class="p">:</span> <span class="n">glob_pattern</span><span class="p">,</span>
                <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="n">options</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">CollectionMetadata</span><span class="p">({}))</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_temporal_extent</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">end_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]],</span> <span class="n">Parameter</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parameter aware temporal_extent normalizer&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">extent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_temporal_extent</span><span class="p">(</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
                <span class="n">convertor</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">)</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">pgnode</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">ProcessBuilder</span><span class="p">)</span> <span class="k">else</span> <span class="n">rfc3339</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="p">))</span>

<div class="viewcode-block" id="DataCube.filter_temporal"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.filter_temporal">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">filter_temporal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">end_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limit the DataCube to a certain date range, which can be specified in several ways:</span>

<span class="sd">        &gt;&gt;&gt; im.filter_temporal(&quot;2019-07-01&quot;, &quot;2019-08-01&quot;)</span>
<span class="sd">        &gt;&gt;&gt; im.filter_temporal([&quot;2019-07-01&quot;, &quot;2019-08-01&quot;])</span>
<span class="sd">        &gt;&gt;&gt; im.filter_temporal(extent=[&quot;2019-07-01&quot;, &quot;2019-08-01&quot;])</span>
<span class="sd">        &gt;&gt;&gt; im.filter_temporal(start_date=&quot;2019-07-01&quot;, end_date=&quot;2019-08-01&quot;])</span>

<span class="sd">        :param start_date: start date of the filter (inclusive), as a string or date object</span>
<span class="sd">        :param end_date: end date of the filter (exclusive), as a string or date object</span>
<span class="sd">        :param extent: two element list/tuple start and end date of the filter</span>
<span class="sd">        :return: An ImageCollection filtered by date.</span>

<span class="sd">        https://open-eo.github.io/openeo-api/processreference/#filter_temporal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;filter_temporal&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s1">&#39;extent&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_temporal_extent</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.filter_bbox"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.filter_bbox">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">filter_bbox</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">west</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">south</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">east</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">north</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">bbox</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limits the data cube to the specified bounding box.</span>

<span class="sd">        The bounding box can be specified in multiple ways.</span>

<span class="sd">            - With keyword arguments::</span>

<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(west=3, south=51, east=4, north=52, crs=4326)</span>

<span class="sd">            - With a (west, south, east, north) list or tuple</span>
<span class="sd">              (note that EPSG:4326 is the default CRS, so it&#39;s not nececarry to specify it explicitly)::</span>

<span class="sd">                &gt;&gt;&gt; cube.filter_bbox([3, 51, 4, 52])</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=[3, 51, 4, 52])</span>

<span class="sd">            - With a bbox dictionary::</span>

<span class="sd">                &gt;&gt;&gt; bbox = {&quot;west&quot;: 3, &quot;south&quot;: 51, &quot;east&quot;: 4, &quot;north&quot;: 52, &quot;crs&quot;: 4326}</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=bbox)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(**bbox)</span>

<span class="sd">            - With a shapely geometry (of which the bounding box will be used)::</span>

<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(geometry)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=geometry)</span>

<span class="sd">            - Passing a parameter::</span>

<span class="sd">                &gt;&gt;&gt; bbox_param = Parameter(name=&quot;my_bbox&quot;, schema=&quot;object&quot;)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox_param)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=bbox_param)</span>
<span class="sd">            </span>
<span class="sd">            - With a CRS other than EPSG 4326::</span>

<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(west=652000, east=672000, north=5161000, south=5181000, crs=32632)</span>

<span class="sd">            - Deprecated: positional arguments are also supported,</span>
<span class="sd">              but follow a non-standard order for legacy reasons::</span>

<span class="sd">                &gt;&gt;&gt; west, east, north, south = 3, 4, 52, 51</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(west, east, north, south)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">bbox</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t mix positional arguments with keyword arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t mix `bbox` with `west`/`south`/`east`/`north` keyword arguments.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">4</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="c1"># Handle old-style west-east-north-south order</span>
                <span class="c1"># TODO remove handling of this legacy order?</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Deprecated argument order usage: `filter_bbox(west, east, north, south)`.&quot;</span>
                              <span class="s2">&quot; Use keyword arguments or tuple/list argument instead.&quot;</span><span class="p">)</span>
                <span class="n">west</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">crs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">4</span>
                                     <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">))):</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bbox</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">):</span>
                    <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">bounds</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;west&quot;</span><span class="p">,</span> <span class="s2">&quot;south&quot;</span><span class="p">,</span> <span class="s2">&quot;east&quot;</span><span class="p">,</span> <span class="s2">&quot;north&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="s2">&quot;crs&quot;</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">:</span>
                        <span class="n">crs</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>

            <span class="n">extent</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;west&#39;</span><span class="p">:</span> <span class="n">west</span><span class="p">,</span> <span class="s1">&#39;east&#39;</span><span class="p">:</span> <span class="n">east</span><span class="p">,</span> <span class="s1">&#39;north&#39;</span><span class="p">:</span> <span class="n">north</span><span class="p">,</span> <span class="s1">&#39;south&#39;</span><span class="p">:</span> <span class="n">south</span><span class="p">}</span>
            <span class="n">extent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dict_no_none</span><span class="p">(</span><span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;filter_bbox&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s1">&#39;extent&#39;</span><span class="p">:</span> <span class="n">extent</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.filter_spatial"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.filter_spatial">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">filter_spatial</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">geometries</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limits the data cube over the spatial dimensions to the specified geometries.</span>

<span class="sd">            - For polygons, the filter retains a pixel in the data cube if the point at the pixel center intersects with</span>
<span class="sd">              at least one of the polygons (as defined in the Simple Features standard by the OGC).</span>
<span class="sd">            - For points, the process considers the closest pixel center.</span>
<span class="sd">            - For lines (line strings), the process considers all the pixels whose centers are closest to at least one</span>
<span class="sd">              point on the line.</span>

<span class="sd">        More specifically, pixels outside of the bounding box of the given geometry will not be available after filtering.</span>
<span class="sd">        All pixels inside the bounding box that are not retained will be set to null (no data).</span>

<span class="sd">        :param geometries: One or more geometries used for filtering, specified as GeoJSON in EPSG:4326.</span>
<span class="sd">        :return: A data cube restricted to the specified geometries. The dimensions and dimension properties (name,</span>
<span class="sd">            type, labels, reference system and resolution) remain unchanged, except that the spatial dimensions have less</span>
<span class="sd">            (or the same) dimension labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_geojson_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Point&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPoint&quot;</span><span class="p">,</span> <span class="s2">&quot;LineString&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiLineString&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">,</span> <span class="s2">&quot;GeometryCollection&quot;</span><span class="p">,</span> <span class="s2">&quot;FeatureCollection&quot;</span>
        <span class="p">]</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_geometry_argument</span><span class="p">(</span><span class="n">geometries</span><span class="p">,</span> <span class="n">valid_geojson_types</span><span class="o">=</span><span class="n">valid_geojson_types</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;filter_spatial&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s1">&#39;geometries&#39;</span><span class="p">:</span> <span class="n">geometries</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.filter_bands"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.filter_bands">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">filter_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the data cube by the given bands</span>

<span class="sd">        :param bands: list of band names, common names or band indices. Single band name can also be given as string.</span>
<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="n">bands</span><span class="p">]</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">band_name</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;filter_bands&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span> <span class="s1">&#39;bands&#39;</span><span class="p">:</span> <span class="n">bands</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">cube</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">filter_bands</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cube</span></div>

    <span class="n">band_filter</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">filter_bands</span><span class="p">,</span> <span class="s2">&quot;band_filter&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.band"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.band">[docs]</a>    <span class="k">def</span> <span class="nf">band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter out a single band</span>

<span class="sd">        :param band: band name, band common name or band index.</span>
<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_band_index</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_bands</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;array_element&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;from_parameter&#39;</span><span class="p">:</span> <span class="s1">&#39;data&#39;</span><span class="p">},</span>
                <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">band_index</span>
            <span class="p">},</span>
        <span class="p">))</span></div>

<div class="viewcode-block" id="DataCube.resample_spatial"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.resample_spatial">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">resample_spatial</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">projection</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;near&#39;</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;upper-left&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;resample_spatial&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;resolution&#39;</span><span class="p">:</span> <span class="n">resolution</span><span class="p">,</span>
            <span class="s1">&#39;projection&#39;</span><span class="p">:</span> <span class="n">projection</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;align&#39;</span><span class="p">:</span> <span class="n">align</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.resample_cube_spatial"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.resample_cube_spatial">[docs]</a>    <span class="k">def</span> <span class="nf">resample_cube_spatial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;near&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples the spatial dimensions (x,y) from a source data cube to align with the corresponding</span>
<span class="sd">        dimensions of the given target data cube.</span>
<span class="sd">        Returns a new data cube with the resampled dimensions.</span>

<span class="sd">        To resample a data cube to a specific resolution or projection regardless of an existing target</span>
<span class="sd">        data cube, refer to :py:meth:`resample_spatial`.</span>

<span class="sd">        :param target: A data cube that describes the spatial target resolution.</span>
<span class="sd">        :param method: Resampling method to use.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s2">&quot;resample_cube_spatial&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.resample_cube_temporal"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.resample_cube_temporal">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">resample_cube_temporal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">valid_within</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples one or more given temporal dimensions from a source data cube to align with the corresponding</span>
<span class="sd">        dimensions of the given target data cube using the nearest neighbor method.</span>
<span class="sd">        Returns a new data cube with the resampled dimensions.</span>

<span class="sd">        By default, this process simply takes the nearest neighbor independent of the value (including values such as</span>
<span class="sd">        no-data / ``null``). Depending on the data cubes this may lead to values being assigned to two target timestamps.</span>
<span class="sd">        To only consider valid values in a specific range around the target timestamps, use the parameter ``valid_within``.</span>

<span class="sd">        The rare case of ties is resolved by choosing the earlier timestamps.</span>

<span class="sd">        :param target: A data cube that describes the temporal target resolution.</span>
<span class="sd">        :param dimension: The name of the temporal dimension to resample.</span>
<span class="sd">        :param valid_within:</span>
<span class="sd">        :return:</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="s2">&quot;resample_cube_temporal&quot;</span><span class="p">,</span>
            <span class="n">dict_no_none</span><span class="p">({</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">,</span> <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="n">dimension</span><span class="p">,</span> <span class="s2">&quot;valid_within&quot;</span><span class="p">:</span> <span class="n">valid_within</span><span class="p">})</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_operator_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generic handling of (mathematical) binary operator&quot;&quot;&quot;</span>
        <span class="n">band_math_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">band_math_mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandmath_operator_binary_scalar</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataCube</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandmath_operator_binary_cubes</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataCube</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_operator_binary_cubes</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">other</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">}}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">},</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">other</span><span class="p">}</span>
                <span class="c1"># TODO #123: support appending to pre-existing apply process instead of adding a whole new one</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">process</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">args</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">OperatorException</span><span class="p">(</span><span class="s2">&quot;Unsupported operator </span><span class="si">{op!r}</span><span class="s2"> with </span><span class="si">{other!r}</span><span class="s2"> (band math mode=</span><span class="si">{b}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">band_math_mode</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_operator_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="n">band_math_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">band_math_mode</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandmath_operator_unary</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">OperatorException</span><span class="p">(</span><span class="s2">&quot;Unsupported unary operator </span><span class="si">{op!r}</span><span class="s2"> (band math mode=</span><span class="si">{b}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">band_math_mode</span><span class="p">))</span>

<div class="viewcode-block" id="DataCube.add"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.add">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.subtract"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.subtract">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;subtract&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.divide"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.divide">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;divide&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.multiply"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.multiply">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;multiply&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.normalized_difference"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.normalized_difference">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">normalized_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="c1"># This DataCube method is only a convenience function when in band math mode</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">other</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;normalized_difference&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.logical_or"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.logical_or">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply element-wise logical `or` operation</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: logical_or(this, other)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.logical_and"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.logical_and">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply element-wise logical `and` operation</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: logical_and(this, other)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;not&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_unary</span><span class="p">(</span><span class="s2">&quot;not&quot;</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;neq&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;neq&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;eq&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pixelwise comparison of this data cube with another cube or constant.</span>

<span class="sd">        :param other: Another data cube, or a constant</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;eq&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;gt&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pairwise comparison of the bands in this data cube with the bands in the &#39;other&#39; data cube.</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: this &gt; other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;gt&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;ge&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;gte&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pairwise comparison of the bands in this data cube with the bands in the &#39;other&#39; data cube.</span>
<span class="sd">        The number of bands in both data cubes has to be the same.</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: this &lt; other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;lte&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;subtract&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;subtract&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;multiply&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;multiply&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;multiply&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;divide&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;divide&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;power&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;power&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span>
            <span class="n">PGNode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;power&quot;</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="p">))</span>

<div class="viewcode-block" id="DataCube.power"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.power">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;power&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.ln"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.ln">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;ln&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ln</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_unary</span><span class="p">(</span><span class="s2">&quot;ln&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.logarithm"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.logarithm">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logarithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_unary</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.log2"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.log2">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logarithm</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.log10"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.log10">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logarithm</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></div>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;operator&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bandmath_operator_binary_cubes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">,</span>
                                        <span class="n">left_arg_name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">right_arg_name</span><span class="o">=</span><span class="s2">&quot;y&quot;</span>
                                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Band math binary operator with cube as right hand side argument&quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">BandMathException</span><span class="p">(</span><span class="s2">&quot;&#39;Band math&#39; between bands of different data cubes is not supported yet.&quot;</span><span class="p">)</span>

        <span class="c1"># Build reducer&#39;s sub-processgraph</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="n">left_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_node&quot;</span><span class="p">:</span> <span class="n">left</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()},</span>
                <span class="n">right_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_node&quot;</span><span class="p">:</span> <span class="n">right</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()},</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span><span class="n">merged</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_bandmath_operator_binary_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Band math binary operator with scalar value (int or float) as right hand side argument&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()}</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span>
            <span class="n">PGNode</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="p">))</span>

    <span class="k">def</span> <span class="nf">_bandmath_operator_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span>
            <span class="n">PGNode</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="p">))</span>

    <span class="k">def</span> <span class="nf">_in_bandmath_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># TODO #123 is it (still) necessary to make &quot;band&quot; math a special case?</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="p">,</span> <span class="n">ReduceNode</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="o">.</span><span class="n">band_math_mode</span>

    <span class="k">def</span> <span class="nf">_get_bandmath_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ReduceNode</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check we are in bandmath mode and return the node&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">BandMathException</span><span class="p">(</span><span class="s2">&quot;Must be in band math mode already&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span>

    <span class="k">def</span> <span class="nf">_merge_operator_binary_cubes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="n">left_arg_name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
                                     <span class="n">right_arg_name</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Merge two cubes with given operator as overlap_resolver.&quot;&quot;&quot;</span>
        <span class="c1"># TODO #123 reuse an existing merge_cubes process graph if it already exists?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cubes</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">overlap_resolver</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="n">left_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">},</span>
                <span class="n">right_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">},</span>
            <span class="p">}</span>
        <span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_geometry_argument</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">geometry</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">_FromNodeMixin</span><span class="p">],</span>
            <span class="n">valid_geojson_types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">crs</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert input to a geometry as &quot;geojson&quot; subtype object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
            <span class="c1"># Assumption: `geometry` is path to polygon is a path to vector file at backend.</span>
            <span class="c1"># TODO #104: `read_vector` is non-standard process.</span>
            <span class="c1"># TODO: If path exists client side: load it client side?</span>
            <span class="k">return</span> <span class="n">PGNode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;read_vector&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">geometry</span><span class="p">)})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">geometry</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">_FromNodeMixin</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">geometry</span><span class="o">.</span><span class="n">from_node</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">):</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">OpenEoClientException</span><span class="p">(</span><span class="s2">&quot;Invalid geometry argument: </span><span class="si">{g!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="n">geometry</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_geojson_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenEoClientException</span><span class="p">(</span><span class="s2">&quot;Invalid geometry type </span><span class="si">{t!r}</span><span class="s2">, must be one of </span><span class="si">{s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">t</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="n">valid_geojson_types</span>
            <span class="p">))</span>
        <span class="k">if</span> <span class="n">crs</span><span class="p">:</span>
            <span class="c1"># TODO: don&#39;t warn when the crs is Lon-Lat like EPSG:4326?</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Geometry with non-Lon-Lat CRS </span><span class="si">{c!r}</span><span class="s2"> is only supported by specific back-ends.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">crs</span><span class="p">))</span>
            <span class="c1"># TODO #204 alternative for non-standard CRS in GeoJSON object?</span>
            <span class="n">geometry</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">crs</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">geometry</span>

<div class="viewcode-block" id="DataCube.aggregate_spatial"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.aggregate_spatial">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">aggregate_spatial</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">geometries</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="s2">&quot;VectorCube&quot;</span><span class="p">],</span>
            <span class="n">reducer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">target_dimension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">crs</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="c1"># TODO arguments: target dimension, context</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregates statistics for one or more geometries (e.g. zonal statistics for polygons)</span>
<span class="sd">        over the spatial dimensions.</span>

<span class="sd">        :param geometries: a shapely geometry, a GeoJSON-style dictionary,</span>
<span class="sd">            a public GeoJSON URL, or a path (that is valid for the back-end) to a GeoJSON file.</span>
<span class="sd">        :param reducer: a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :param target_dimension: The new dimension name to be used for storing the results.</span>
<span class="sd">        :param crs: The spatial reference system of the provided polygon.</span>
<span class="sd">            By default longitude-latitude (EPSG:4326) is assumed.</span>
<span class="sd">        :param context: Additional data to be passed to the reducer process.</span>

<span class="sd">            .. note:: this ``crs`` argument is a non-standard/experimental feature, only supported by specific back-ends.</span>
<span class="sd">                See https://github.com/Open-EO/openeo-processes/issues/235 for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO #279 aggregate_spatial should return a VectorCube, not a DataCube</span>
        <span class="n">valid_geojson_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Point&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPoint&quot;</span><span class="p">,</span> <span class="s2">&quot;LineString&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiLineString&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">,</span> <span class="s2">&quot;GeometryCollection&quot;</span><span class="p">,</span> <span class="s2">&quot;Feature&quot;</span><span class="p">,</span> <span class="s2">&quot;FeatureCollection&quot;</span>
        <span class="p">]</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_geometry_argument</span><span class="p">(</span><span class="n">geometries</span><span class="p">,</span> <span class="n">valid_geojson_types</span><span class="o">=</span><span class="n">valid_geojson_types</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;aggregate_spatial&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">,</span>
            <span class="o">**</span><span class="n">dict_no_none</span><span class="p">(</span><span class="n">target_dimension</span><span class="o">=</span><span class="n">target_dimension</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_callback</span><span class="p">(</span><span class="n">process</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span> <span class="n">parent_parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a &quot;callback&quot; process: a user defined process that is used by another process (such</span>
<span class="sd">        as `apply`, `apply_dimension`, `reduce`, ....)</span>

<span class="sd">        :param process: process id string, PGNode or callable that uses the ProcessBuilder mechanism to build a process</span>
<span class="sd">        :param parent_parameters: list of parameter names defined for child process</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: autodetect the parameters defined by parent process?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">):</span>
            <span class="c1"># Assume this is already a valid callback process</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">process</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Assume given reducer is a simple predefined reduce process_id</span>
            <span class="k">if</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">openeo</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="n">process_params</span> <span class="o">=</span> <span class="n">get_parameter_names</span><span class="p">(</span><span class="n">openeo</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">process</span><span class="p">])</span>
                <span class="c1"># TODO: switch to &quot;Callable&quot; handling here</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Best effort guess</span>
                <span class="n">process_params</span> <span class="o">=</span> <span class="n">parent_parameters</span>
            <span class="k">if</span> <span class="n">parent_parameters</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">process_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">process_params</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]):</span>
                <span class="c1"># Special case: wrap all parent parameters in an array</span>
                <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span><span class="n">process_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">[{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parent_parameters</span><span class="p">]}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only pass parameters that correspond with an arg name</span>
                <span class="n">common</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">process_params</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">parent_parameters</span><span class="p">)</span>
                <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">common</span><span class="p">}</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="n">process</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">convert_callable_to_pgnode</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="n">parent_parameters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PGNode</span><span class="o">.</span><span class="n">to_process_graph_argument</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.apply_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply_dimension">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">apply_dimension</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">process</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="s2">&quot;latest&quot;</span><span class="p">,</span>
            <span class="c1"># TODO: dimension has no default (per spec)?</span>
            <span class="n">dimension</span><span class="o">=</span><span class="s2">&quot;t&quot;</span><span class="p">,</span>
            <span class="n">target_dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a process to all pixel values along a dimension of a raster data cube. For example,</span>
<span class="sd">        if the temporal dimension is specified the process will work on a time series of pixel values.</span>

<span class="sd">        The process to apply is specified by either `code` and `runtime` in case of a UDF, or by providing a callback function</span>
<span class="sd">        in the `process` argument.</span>

<span class="sd">        The process reduce_dimension also applies a process to pixel values along a dimension, but drops</span>
<span class="sd">        the dimension afterwards. The process apply applies a process to each pixel value in the data cube.</span>

<span class="sd">        The target dimension is the source dimension if not specified otherwise in the target_dimension parameter.</span>
<span class="sd">        The pixel values in the target dimension get replaced by the computed pixel values. The name, type and</span>
<span class="sd">        reference system are preserved.</span>

<span class="sd">        The dimension labels are preserved when the target dimension is the source dimension and the number of</span>
<span class="sd">        pixel values in the source dimension is equal to the number of values computed by the process. Otherwise,</span>
<span class="sd">        the dimension labels will be incrementing integers starting from zero, which can be changed using</span>
<span class="sd">        rename_labels afterwards. The number of labels will equal to the number of values computed by the process.</span>

<span class="sd">        :param code: UDF code or process identifier (optional)</span>
<span class="sd">        :param runtime: UDF runtime to use (optional)</span>
<span class="sd">        :param process: a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :param version: Version of the UDF runtime to use</span>
<span class="sd">        :param dimension: The name of the source dimension to apply the process on. Fails with a DimensionNotAvailable error if the specified dimension does not exist.</span>
<span class="sd">        :param target_dimension: The name of the target dimension or null (the default) to use the source dimension</span>
<span class="sd">            specified in the parameter dimension. By specifying a target dimension, the source dimension is removed.</span>
<span class="sd">            The target dimension with the specified name and the type other (see add_dimension) is created, if it doesn&#39;t exist yet.</span>
<span class="sd">        :param context: Additional data to be passed to the process.</span>

<span class="sd">        :return: A datacube with the UDF applied to the given dimension.</span>
<span class="sd">        :raises: DimensionNotAvailable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">runtime</span><span class="p">:</span>
            <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class and avoid doing same UDF code-runtime-version argument stuff in each method</span>
            <span class="n">callback_process_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_run_udf</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">PGNode</span><span class="o">.</span><span class="n">to_process_graph_argument</span><span class="p">(</span><span class="n">callback_process_node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="ow">or</span> <span class="n">process</span><span class="p">:</span>
            <span class="c1"># TODO EP-3555 unify `code` and `process`</span>
            <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">code</span> <span class="ow">or</span> <span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;context&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenEoClientException</span><span class="p">(</span><span class="s2">&quot;No UDF code or process given&quot;</span><span class="p">)</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;process&quot;</span><span class="p">:</span> <span class="n">process</span><span class="p">,</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">target_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;target_dimension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_dimension</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;context&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span>
        <span class="n">result_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;apply_dimension&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result_cube</span></div>

<div class="viewcode-block" id="DataCube.reduce_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_dimension">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">reduce_dimension</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reducer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">,</span> <span class="n">band_math_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a reduce process with given reducer callback along given dimension</span>

<span class="sd">        :param dimension: the label of the dimension to reduce</span>
<span class="sd">        :param reducer: &quot;child callback&quot; function, see :ref:`callbackfunctions`</span>
<span class="sd">        :param context: Additional data to be passed to the process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: check if dimension is valid according to metadata? #116</span>
        <span class="c1"># TODO: #125 use/test case for `reduce_dimension_binary`?</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;context&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">ReduceNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">process_id</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">,</span>
            <span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
            <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
            <span class="c1"># TODO #123 is it (still) necessary to make &quot;band&quot; math a special case?</span>
            <span class="n">band_math_mode</span><span class="o">=</span><span class="n">band_math_mode</span>
        <span class="p">),</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="n">dimension_name</span><span class="o">=</span><span class="n">dimension</span><span class="p">))</span></div>

    <span class="c1"># @openeo_process</span>
<div class="viewcode-block" id="DataCube.chunk_polygon"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.chunk_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">chunk_polygon</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="s2">&quot;VectorCube&quot;</span><span class="p">],</span>
            <span class="n">process</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">mask_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a process to spatial chunks of a data cube.</span>

<span class="sd">        .. warning:: experimental process: not generally supported, API subject to change.</span>

<span class="sd">        :param chunks: Polygons, provided as a shapely geometry, a GeoJSON-style dictionary,</span>
<span class="sd">            a public GeoJSON URL, or a path (that is valid for the back-end) to a GeoJSON file.</span>
<span class="sd">        :param process: &quot;child callback&quot; function, see :ref:`callbackfunctions`</span>
<span class="sd">        :param mask_value: The value used for cells outside the polygon.</span>
<span class="sd">            This provides a distinction between NoData cells within the polygon (due to e.g. clouds)</span>
<span class="sd">            and masked cells outside it. If no value is provided, NoData cells are used outside the polygon.</span>
<span class="sd">        :param context: Additional data to be passed to the process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        <span class="n">valid_geojson_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">,</span> <span class="s2">&quot;GeometryCollection&quot;</span><span class="p">,</span> <span class="s2">&quot;Feature&quot;</span><span class="p">,</span> <span class="s2">&quot;FeatureCollection&quot;</span><span class="p">]</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_geometry_argument</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">valid_geojson_types</span><span class="o">=</span><span class="n">valid_geojson_types</span><span class="p">)</span>
        <span class="n">mask_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mask_value</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;chunk_polygon&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">mask_value</span><span class="o">=</span><span class="n">mask_value</span><span class="p">,</span>
                <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_reduce_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reducer</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="c1"># TODO #123 is it (still) necessary to make &quot;band&quot; math a special case?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">,</span> <span class="n">band_math_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce_temporal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reducer</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">temporal_dimension</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.reduce_bands_udf"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_bands_udf">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_bands_udf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;latest&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply reduce (`reduce_dimension`) process with given UDF along band/spectral dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class and avoid doing same UDF code-runtime-version argument stuff in each method</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_bands</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_run_udf</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span></div>

<div class="viewcode-block" id="DataCube.add_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.add_dimension">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">add_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new named dimension to the data cube.</span>
<span class="sd">        Afterwards, the dimension can be referenced with the specified name. If a dimension with the specified name exists,</span>
<span class="sd">        the process fails with a DimensionExists error. The dimension label of the dimension is set to the specified label.</span>

<span class="sd">        This call does not modify the datacube in place, but returns a new datacube with the additional dimension.</span>

<span class="sd">        :param name: The name of the dimension to add</span>
<span class="sd">        :param label: The dimension label.</span>
<span class="sd">        :param type: Dimension type, allowed values: &#39;spatial&#39;, &#39;temporal&#39;, &#39;bands&#39;, &#39;other&#39;, default value is &#39;other&#39;</span>
<span class="sd">        :return: The data cube with a newly added dimension. The new dimension has exactly one dimension label. All other dimensions remain unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;add_dimension&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">({</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">}),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">add_dimension</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.drop_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.drop_dimension">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">drop_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops a dimension from the data cube.</span>
<span class="sd">        Dropping a dimension only works on dimensions with a single dimension label left, otherwise the process fails</span>
<span class="sd">        with a DimensionLabelCountMismatch exception. Dimension values can be reduced to a single value with a filter</span>
<span class="sd">        such as filter_bands or the reduce_dimension process. If a dimension with the specified name does not exist,</span>
<span class="sd">        the process fails with a DimensionNotAvailable exception.</span>

<span class="sd">        :param name: The name of the dimension to drop</span>
<span class="sd">        :return: The data cube with the given dimension dropped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;drop_dimension&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">drop_dimension</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_create_run_udf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PGNode</span><span class="p">:</span>
        <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class</span>
        <span class="k">return</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;run_udf&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;data&quot;</span>
                <span class="p">},</span>
                <span class="s2">&quot;runtime&quot;</span><span class="p">:</span> <span class="n">runtime</span><span class="p">,</span>
                <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="n">version</span><span class="p">,</span>
                <span class="s2">&quot;udf&quot;</span><span class="p">:</span> <span class="n">code</span>
            <span class="p">})</span>

<div class="viewcode-block" id="DataCube.reduce_temporal_udf"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_temporal_udf">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reduce_temporal_udf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;latest&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply reduce (`reduce_dimension`) process with given UDF along temporal dimension.</span>

<span class="sd">        :param code: The UDF code, compatible with the given runtime and version</span>
<span class="sd">        :param runtime: The UDF runtime</span>
<span class="sd">        :param version: The UDF runtime version</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class and avoid doing same UDF code-runtime-version argument stuff in each method</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_temporal</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_run_udf</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span></div>

    <span class="n">reduce_tiles_over_time</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">reduce_temporal_udf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reduce_tiles_over_time&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.apply_neighborhood"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply_neighborhood">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">apply_neighborhood</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">process</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">size</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span>
            <span class="n">overlap</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a focal process to a data cube.</span>

<span class="sd">        A focal process is a process that works on a &#39;neighbourhood&#39; of pixels. The neighbourhood can extend into multiple dimensions, this extent is specified by the `size` argument. It is not only (part of) the size of the input window, but also the size of the output for a given position of the sliding window. The sliding window moves with multiples of `size`.</span>

<span class="sd">        An overlap can be specified so that neighbourhoods can have overlapping boundaries. This allows for continuity of the output. The values included in the data cube as overlap can&#39;t be modified by the given `process`.</span>

<span class="sd">        The neighbourhood size should be kept small enough, to avoid running beyond computational resources, but a too small size will result in a larger number of process invocations, which may slow down processing. Window sizes for spatial dimensions typically are in the range of 64 to 512 pixels, while overlaps of 8 to 32 pixels are common.</span>

<span class="sd">        The process must not add new dimensions, or remove entire dimensions, but the result can have different dimension labels.</span>

<span class="sd">        For the special case of 2D convolution, it is recommended to use ``apply_kernel()``.</span>

<span class="sd">        :param size:</span>
<span class="sd">        :param overlap:</span>
<span class="sd">        :param process: a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :param context: Additional data to be passed to the process.</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;apply_neighborhood&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">process</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]),</span>
                <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
                <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.apply"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a unary process (a local operation) to each value of the specified or all dimensions in the data cube.</span>

<span class="sd">        :param process: the name of a process, or a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :param dimensions: The names of the dimensions to apply the process on. Defaults to an empty array so that all dimensions are used.</span>
<span class="sd">        :param context: Additional data to be passed to the process.</span>

<span class="sd">        :return: A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;apply&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">({</span>
                <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s2">&quot;process&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]),</span>
                <span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="n">context</span><span class="p">,</span>
            <span class="p">})</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.reduce_temporal_simple"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_temporal_simple">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reduce_temporal_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Do temporal reduce with a simple given process as callback.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_temporal</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">process_id</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;data&quot;</span><span class="p">}}</span>
        <span class="p">))</span></div>

<div class="viewcode-block" id="DataCube.min_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.min_time">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">min_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Finds the minimum value of a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.max_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.max_time">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">max_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the maximum value of a time series for all bands of the input dataset.</span>

<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.mean_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.mean_time">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">mean_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Finds the mean value of a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.median_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.median_time">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">median_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Finds the median value of a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;median&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.count_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.count_time">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">count_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of images with a valid mask in a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.aggregate_temporal"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.aggregate_temporal">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">aggregate_temporal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span>
            <span class="n">reducer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">dimension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a temporal aggregation based on an array of date and/or time intervals.</span>

<span class="sd">        Calendar hierarchies such as year, month, week etc. must be transformed into specific intervals by the clients. For each interval, all data along the dimension will be passed through the reducer. The computed values will be projected to the labels, so the number of labels and the number of intervals need to be equal.</span>

<span class="sd">        If the dimension is not set, the data cube is expected to only have one temporal dimension.</span>

<span class="sd">        :param intervals: Temporal left-closed intervals so that the start time is contained, but not the end time.</span>
<span class="sd">        :param reducer: A reducer to be applied on all values along the specified dimension. The reducer must be a callable process (or a set processes) that accepts an array and computes a single return value of the same type as the input values, for example median.</span>
<span class="sd">        :param labels: Labels for the intervals. The number of labels and the number of groups need to be equal.</span>
<span class="sd">        :param dimension: The temporal dimension for aggregation. All data along the dimension will be passed through the specified reducer. If the dimension is not set, the data cube is expected to only have one temporal dimension.</span>
<span class="sd">        :param context: Additional data to be passed to the reducer. Not set by default.</span>

<span class="sd">        :return: An ImageCollection containing  a result for each time window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;aggregate_temporal&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span>
                <span class="n">reducer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]),</span>
                <span class="n">context</span><span class="o">=</span><span class="n">context</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.aggregate_temporal_period"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.aggregate_temporal_period">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">aggregate_temporal_period</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">period</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">reducer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">dimension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a temporal aggregation based on calendar hierarchies such as years, months or seasons. For other calendar hierarchies aggregate_temporal can be used.</span>

<span class="sd">        For each interval, all data along the dimension will be passed through the reducer.</span>

<span class="sd">        If the dimension is not set or is set to null, the data cube is expected to only have one temporal dimension.</span>

<span class="sd">        The period argument specifies the time intervals to aggregate. The following pre-defined values are available:</span>

<span class="sd">        - hour: Hour of the day</span>
<span class="sd">        - day: Day of the year</span>
<span class="sd">        - week: Week of the year</span>
<span class="sd">        - dekad: Ten day periods, counted per year with three periods per month (day 1 - 10, 11 - 20 and 21 - end of month). The third dekad of the month can range from 8 to 11 days. For example, the fourth dekad is Feb, 1 - Feb, 10 each year.</span>
<span class="sd">        - month: Month of the year</span>
<span class="sd">        - season: Three month periods of the calendar seasons (December - February, March - May, June - August, September - November).</span>
<span class="sd">        - tropical-season: Six month periods of the tropical seasons (November - April, May - October).</span>
<span class="sd">        - year: Proleptic years</span>
<span class="sd">        - decade: Ten year periods (0-to-9 decade), from a year ending in a 0 to the next year ending in a 9.</span>
<span class="sd">        - decade-ad: Ten year periods (1-to-0 decade) better aligned with the Anno Domini (AD) calendar era, from a year ending in a 1 to the next year ending in a 0.</span>


<span class="sd">        :param period: The period of the time intervals to aggregate.</span>
<span class="sd">        :param reducer: A reducer to be applied on all values along the specified dimension. The reducer must be a callable process (or a set processes) that accepts an array and computes a single return value of the same type as the input values, for example median.</span>
<span class="sd">        :param dimension: The temporal dimension for aggregation. All data along the dimension will be passed through the specified reducer. If the dimension is not set, the data cube is expected to only have one temporal dimension.</span>
<span class="sd">        :param context: Additional data to be passed to the reducer.</span>

<span class="sd">        :return: A data cube with the same dimensions. The dimension properties (name, type, labels, reference system and resolution) remain unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;aggregate_temporal_period&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
                <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span>
                <span class="n">reducer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]),</span>
                <span class="n">context</span><span class="o">=</span><span class="n">context</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.ndvi"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.ndvi">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">ndvi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">red</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_band</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalized Difference Vegetation Index (NDVI)</span>

<span class="sd">        :param nir: (optional) name of NIR band</span>
<span class="sd">        :param red: (optional) name of red band</span>
<span class="sd">        :param target_band: (optional) name of the newly created band</span>

<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">append_band</span><span class="p">(</span><span class="n">Band</span><span class="p">(</span><span class="n">target_band</span><span class="p">,</span> <span class="s2">&quot;ndvi&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;ndvi&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">nir</span><span class="o">=</span><span class="n">nir</span><span class="p">,</span> <span class="n">red</span><span class="o">=</span><span class="n">red</span><span class="p">,</span> <span class="n">target_band</span><span class="o">=</span><span class="n">target_band</span>
            <span class="p">),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.rename_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.rename_dimension">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">rename_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames a dimension in the data cube while preserving all other properties.</span>

<span class="sd">        :param source: The current name of the dimension. Fails with a DimensionNotAvailable error if the specified dimension does not exist.</span>
<span class="sd">        :param target: A new Name for the dimension. Fails with a DimensionExists error if a dimension with the specified name exists.</span>

<span class="sd">        :return: A new datacube with the dimension renamed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dimension_names</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Target dimension name conflicts with existing dimension: </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;rename_dimension&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span>
            <span class="p">),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">rename_dimension</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.rename_labels"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.rename_labels">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">rename_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames the labels of the specified dimension in the data cube from source to target.</span>

<span class="sd">        :param dimension: Dimension name</span>
<span class="sd">        :param target: The new names for the labels.</span>
<span class="sd">        :param source: The names of the labels as they are currently in the data cube.</span>

<span class="sd">        :return: An DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;rename_labels&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">source</span>
            <span class="p">),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">rename_labels</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.linear_scale_range"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.linear_scale_range">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;apply&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">linear_scale_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_min</span><span class="p">,</span> <span class="n">input_max</span><span class="p">,</span> <span class="n">output_min</span><span class="p">,</span> <span class="n">output_max</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a linear transformation between the input and output range.</span>

<span class="sd">        The given number in x is clipped to the bounds specified in inputMin and inputMax so that the underlying formula</span>

<span class="sd">         ((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin</span>

<span class="sd">         never returns any value lower than outputMin or greater than outputMax.</span>

<span class="sd">        Potential use case include scaling values to the 8-bit range (0 - 255) often used for numeric representation of</span>
<span class="sd">        values in one of the channels of the RGB colour model or calculating percentages (0 - 100).</span>

<span class="sd">        The no-data value null is passed through and therefore gets propagated.</span>

<span class="sd">        :param input_min: Minimum input value</span>
<span class="sd">        :param input_max: Maximum input value</span>
<span class="sd">        :param output_min: Minimum value of the desired output range.</span>
<span class="sd">        :param output_max: Maximum value of the desired output range.</span>
<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">linear_scale_range</span><span class="p">(</span><span class="n">input_min</span><span class="p">,</span> <span class="n">input_max</span><span class="p">,</span> <span class="n">output_min</span><span class="p">,</span> <span class="n">output_max</span><span class="p">))</span></div>

<div class="viewcode-block" id="DataCube.mask"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.mask">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a mask to a raster data cube. To apply a vector mask use `mask_polygon`.</span>

<span class="sd">        A mask is a raster data cube for which corresponding pixels among `data` and `mask`</span>
<span class="sd">        are compared and those pixels in `data` are replaced whose pixels in `mask` are non-zero</span>
<span class="sd">        (for numbers) or true (for boolean values).</span>
<span class="sd">        The pixel values are replaced with the value specified for `replacement`,</span>
<span class="sd">        which defaults to null (no data).</span>

<span class="sd">        :param mask: the raster mask</span>
<span class="sd">        :param replacement: the value to replace the masked pixels with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.mask_polygon"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.mask_polygon">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">mask_polygon</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="s2">&quot;VectorCube&quot;</span><span class="p">],</span>
            <span class="n">srs</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">replacement</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inside</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a polygon mask to a raster data cube. To apply a raster mask use `mask`.</span>

<span class="sd">        All pixels for which the point at the pixel center does not intersect with any</span>
<span class="sd">        polygon (as defined in the Simple Features standard by the OGC) are replaced.</span>
<span class="sd">        This behaviour can be inverted by setting the parameter `inside` to true.</span>

<span class="sd">        The pixel values are replaced with the value specified for `replacement`,</span>
<span class="sd">        which defaults to `no data`.</span>

<span class="sd">        :param mask: The geometry to mask with: a shapely geometry, a GeoJSON-style dictionary,</span>
<span class="sd">            a public GeoJSON URL, or a path (that is valid for the back-end) to a GeoJSON file.</span>
<span class="sd">        :param srs: The spatial reference system of the provided polygon.</span>
<span class="sd">            By default longitude-latitude (EPSG:4326) is assumed.</span>

<span class="sd">            .. note:: this ``srs`` argument is a non-standard/experimental feature, only supported by specific back-ends.</span>
<span class="sd">                See https://github.com/Open-EO/openeo-processes/issues/235 for details.</span>
<span class="sd">        :param replacement: the value to replace the masked pixels with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_geojson_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">,</span> <span class="s2">&quot;GeometryCollection&quot;</span><span class="p">,</span> <span class="s2">&quot;Feature&quot;</span><span class="p">,</span> <span class="s2">&quot;FeatureCollection&quot;</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_geometry_argument</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">valid_geojson_types</span><span class="o">=</span><span class="n">valid_geojson_types</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">srs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;mask_polygon&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span><span class="p">,</span>
                <span class="n">inside</span><span class="o">=</span><span class="n">inside</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.merge_cubes"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.merge_cubes">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">merge_cubes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">,</span>
            <span class="n">overlap_resolver</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merging two data cubes</span>

<span class="sd">        The data cubes have to be compatible. A merge operation without overlap should be reversible with (a set of) filter operations for each of the two cubes. The process performs the join on overlapping dimensions, with the same name and type.</span>
<span class="sd">        An overlapping dimension has the same name, type, reference system and resolution in both dimensions, but can have different labels. One of the dimensions can have different labels, for all other dimensions the labels must be equal. If data overlaps, the parameter overlap_resolver must be specified to resolve the overlap.</span>

<span class="sd">        Examples for merging two data cubes:</span>

<span class="sd">        #. Data cubes with the dimensions x, y, t and bands have the same dimension labels in x,y and t, but the labels for the dimension bands are B1 and B2 for the first cube and B3 and B4. An overlap resolver is not needed. The merged data cube has the dimensions x, y, t and bands and the dimension bands has four dimension labels: B1, B2, B3, B4.</span>
<span class="sd">        #. Data cubes with the dimensions x, y, t and bands have the same dimension labels in x,y and t, but the labels for the dimension bands are B1 and B2 for the first data cube and B2 and B3 for the second. An overlap resolver is required to resolve overlap in band B2. The merged data cube has the dimensions x, y, t and bands and the dimension bands has three dimension labels: B1, B2, B3.</span>
<span class="sd">        #. Data cubes with the dimensions x, y and t have the same dimension labels in x,y and t. There are two options:</span>
<span class="sd">                * Keep the overlapping values separately in the merged data cube: An overlap resolver is not needed, but for each data cube you need to add a new dimension using add_dimension. The new dimensions must be equal, except that the labels for the new dimensions must differ by name. The merged data cube has the same dimensions and labels as the original data cubes, plus the dimension added with add_dimension, which has the two dimension labels after the merge.</span>
<span class="sd">                * Combine the overlapping values into a single value: An overlap resolver is required to resolve the overlap for all pixels. The merged data cube has the same dimensions and labels as the original data cubes, but all pixel values have been processed by the overlap resolver.</span>
<span class="sd">        #. Merging a data cube with dimensions x, y, t with another cube with dimensions x, y will join on the x, y dimension, so the lower dimension cube is merged with each time step in the higher dimensional cube. This can for instance be used to apply a digital elevation model to a spatiotemporal data cube.</span>

<span class="sd">        :param other: The data cube to merge with.</span>
<span class="sd">        :param overlap_resolver: A reduction operator that resolves the conflict if the data overlaps. The reducer must return a value of the same data type as the input values are. The reduction operator may be a single process such as multiply or consist of multiple sub-processes. null (the default) can be specified if no overlap resolver is required.</span>
<span class="sd">        :param context: Additional data to be passed to the process.</span>

<span class="sd">        :return: The merged data cube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cube1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cube2&#39;</span><span class="p">:</span> <span class="n">other</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">overlap_resolver</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;overlap_resolver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">overlap_resolver</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
        <span class="c1"># Minimal client side metadata merging</span>
        <span class="n">merged_metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">has_band_dimension</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataCube</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">has_band_dimension</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged_metadata</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
                    <span class="n">merged_metadata</span> <span class="o">=</span> <span class="n">merged_metadata</span><span class="o">.</span><span class="n">append_band</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># TODO: warn about missing overlap_resolver if we can detect that one is required?</span>
        <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;context&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;merge_cubes&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">merged_metadata</span><span class="p">)</span></div>

    <span class="n">merge</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">merge_cubes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;merge&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.apply_kernel"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply_kernel">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">apply_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">border</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">replace_invalid</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a focal operation based on a weighted kernel to each value of the specified dimensions in the data cube.</span>

<span class="sd">        The border parameter determines how the data is extended when the kernel overlaps with the borders.</span>
<span class="sd">        The following options are available:</span>

<span class="sd">        * numeric value - fill with a user-defined constant number n: nnnnnn|abcdefgh|nnnnnn (default, with n = 0)</span>
<span class="sd">        * replicate - repeat the value from the pixel at the border: aaaaaa|abcdefgh|hhhhhh</span>
<span class="sd">        * reflect - mirror/reflect from the border: fedcba|abcdefgh|hgfedc</span>
<span class="sd">        * reflect_pixel - mirror/reflect from the center of the pixel at the border: gfedcb|abcdefgh|gfedcb</span>
<span class="sd">        * wrap - repeat/wrap the image: cdefgh|abcdefgh|abcdef</span>


<span class="sd">        :param kernel: The kernel to be applied on the data cube. The kernel has to be as many dimensions as the data cube has dimensions.</span>
<span class="sd">        :param factor: A factor that is multiplied to each value computed by the focal operation. This is basically a shortcut for explicitly multiplying each value by a factor afterwards, which is often required for some kernel-based algorithms such as the Gaussian blur.</span>
<span class="sd">        :param border: Determines how the data is extended when the kernel overlaps with the borders. Defaults to fill the border with zeroes.</span>
<span class="sd">        :param replace_invalid: This parameter specifies the value to replace non-numerical or infinite numerical values with. By default, those values are replaced with zeroes.</span>
<span class="sd">        :return: A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;apply_kernel&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="n">kernel</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">kernel</span><span class="p">,</span>
            <span class="s1">&#39;factor&#39;</span><span class="p">:</span> <span class="n">factor</span><span class="p">,</span>
            <span class="s1">&#39;border&#39;</span><span class="p">:</span> <span class="n">border</span><span class="p">,</span>
            <span class="s1">&#39;replace_invalid&#39;</span><span class="p">:</span> <span class="n">replace_invalid</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.resolution_merge"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.resolution_merge">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">resolution_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">high_resolution_bands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">low_resolution_bands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
                         <span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolution merging algorithms try to improve the spatial resolution of lower resolution bands</span>
<span class="sd">        (e.g. Sentinel-2 20M) based on higher resolution bands. (e.g. Sentinel-2 10M).</span>

<span class="sd">        External references:</span>

<span class="sd">        `Pansharpening explained &lt;https://bok.eo4geo.eu/IP2-1-3&gt;`_</span>

<span class="sd">        `Example publication: &#39;Improving the Spatial Resolution of Land Surface Phenology by Fusing Medium- and</span>
<span class="sd">        Coarse-Resolution Inputs&#39; &lt;https://doi.org/10.1109/TGRS.2016.2537929&gt;`_</span>

<span class="sd">        .. warning:: experimental process: not generally supported, API subject to change.</span>

<span class="sd">        :param high_resolution_bands: A list of band names to use as &#39;high-resolution&#39; band. Either the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands). If unique band name and common name conflict, the unique band name has higher priority. The order of the specified array defines the order of the bands in the data cube. If multiple bands match a common name, all matched bands are included in the original order. These bands will remain unmodified.</span>
<span class="sd">        :param low_resolution_bands: A list of band names for which the spatial resolution should be increased. Either the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands). If unique band name and common name conflict, the unique band name has higher priority. The order of the specified array defines the order of the bands in the data cube. If multiple bands match a common name, all matched bands are included in the original order. These bands will be modified by the process.</span>
<span class="sd">        :param method: The method to use. The supported algorithms can vary between back-ends. Set to `null` (the default) to allow the back-end to choose, which will improve portability, but reduce reproducibility..</span>
<span class="sd">        :return: A datacube with the same bands and metadata as the input, but algorithmically increased spatial resolution for the selected bands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;resolution_merge&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;high_resolution_bands&#39;</span><span class="p">:</span> <span class="n">high_resolution_bands</span><span class="p">,</span>
            <span class="s1">&#39;low_resolution_bands&#39;</span><span class="p">:</span> <span class="n">low_resolution_bands</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>

        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.raster_to_vector"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.raster_to_vector">[docs]</a>    <span class="k">def</span> <span class="nf">raster_to_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorCube</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts this raster data cube into a :py:class:`~openeo.rest.vectorcube.VectorCube`.</span>
<span class="sd">        The bounding polygon of homogenous areas of pixels is constructed.</span>

<span class="sd">        .. warning:: experimental process: not generally supported, API subject to change.</span>

<span class="sd">        :return: a :py:class:`~openeo.rest.vectorcube.VectorCube`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pg_node</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;raster_to_vector&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">VectorCube</span><span class="p">(</span><span class="n">pg_node</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

    <span class="c1">####VIEW methods #######</span>

<div class="viewcode-block" id="DataCube.polygonal_mean_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_mean_timeseries">[docs]</a>    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use :py:meth:`aggregate_spatial` with reducer ``&#39;mean&#39;``.&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">polygonal_mean_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a mean time series for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_spatial</span><span class="p">(</span><span class="n">geometries</span><span class="o">=</span><span class="n">polygon</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.polygonal_histogram_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_histogram_timeseries">[docs]</a>    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use :py:meth:`aggregate_spatial` with reducer ``&#39;histogram&#39;``.&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">polygonal_histogram_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a histogram time series for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_spatial</span><span class="p">(</span><span class="n">geometries</span><span class="o">=</span><span class="n">polygon</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="s2">&quot;histogram&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.polygonal_median_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_median_timeseries">[docs]</a>    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use :py:meth:`aggregate_spatial` with reducer ``&#39;median&#39;``.&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">polygonal_median_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a median time series for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_spatial</span><span class="p">(</span><span class="n">geometries</span><span class="o">=</span><span class="n">polygon</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.polygonal_standarddeviation_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_standarddeviation_timeseries">[docs]</a>    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use :py:meth:`aggregate_spatial` with reducer ``&#39;sd&#39;``.&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.10.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">polygonal_standarddeviation_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a time series of standard deviations for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_spatial</span><span class="p">(</span><span class="n">geometries</span><span class="o">=</span><span class="n">polygon</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="s2">&quot;sd&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.ard_surface_reflectance"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.ard_surface_reflectance">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">ard_surface_reflectance</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">atmospheric_correction_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">cloud_detection_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">elevation_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">atmospheric_correction_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cloud_detection_options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes CARD4L compliant surface reflectance values from optical input.</span>

<span class="sd">        :param atmospheric_correction_method: The atmospheric correction method to use.</span>
<span class="sd">        :param cloud_detection_method: The cloud detection method to use.</span>
<span class="sd">        :param elevation_model: The digital elevation model to use, leave empty to allow the back-end to make a suitable choice.</span>
<span class="sd">        :param atmospheric_correction_options: Proprietary options for the atmospheric correction method.</span>
<span class="sd">        :param cloud_detection_options: Proprietary options for the cloud detection method.</span>
<span class="sd">        :return: Data cube containing bottom of atmosphere reflectances with atmospheric disturbances like clouds and cloud shadows removed. The data returned is CARD4L compliant and contains metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;ard_surface_reflectance&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;atmospheric_correction_method&#39;</span><span class="p">:</span> <span class="n">atmospheric_correction_method</span><span class="p">,</span>
            <span class="s1">&#39;cloud_detection_method&#39;</span><span class="p">:</span> <span class="n">cloud_detection_method</span><span class="p">,</span>
            <span class="s1">&#39;elevation_model&#39;</span><span class="p">:</span> <span class="n">elevation_model</span><span class="p">,</span>
            <span class="s1">&#39;atmospheric_correction_options&#39;</span><span class="p">:</span> <span class="n">atmospheric_correction_options</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="s1">&#39;cloud_detection_options&#39;</span><span class="p">:</span> <span class="n">cloud_detection_options</span> <span class="ow">or</span> <span class="p">{},</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.atmospheric_correction"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.atmospheric_correction">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">atmospheric_correction</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">elevation_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies an atmospheric correction that converts top of atmosphere reflectance values into bottom of atmosphere/top of canopy reflectance values.</span>

<span class="sd">        Note that multiple atmospheric methods exist, but may not be supported by all backends. The method parameter gives</span>
<span class="sd">        you the option of requiring a specific method, but this may result in an error if the backend does not support it.</span>

<span class="sd">        :param method: The atmospheric correction method to use. To get reproducible results, you have to set a specific method. Set to `null` to allow the back-end to choose, which will improve portability, but reduce reproducibility as you *may* get different results if you run the processes multiple times.</span>
<span class="sd">        :param elevation_model: The digital elevation model to use, leave empty to allow the back-end to make a suitable choice.</span>
<span class="sd">        :param options: Proprietary options for the atmospheric correction method.</span>
<span class="sd">        :return: datacube with bottom of atmosphere reflectances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;atmospheric_correction&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;elevation_model&#39;</span><span class="p">:</span> <span class="n">elevation_model</span><span class="p">,</span>
            <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="n">options</span> <span class="ow">or</span> <span class="p">{},</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.save_result"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.save_result">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">save_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">list_output_formats</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid format </span><span class="si">{f!r}</span><span class="s2">. Should be one of </span><span class="si">{s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">formats</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;save_result&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="nb">format</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="n">options</span> <span class="ow">or</span> <span class="p">{}</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.download"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.download">[docs]</a>    <span class="k">def</span> <span class="nf">download</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Download image collection, e.g. as GeoTIFF.</span>
<span class="sd">        If outputfile is provided, the result is stored on disk locally, otherwise, a bytes object is returned.</span>
<span class="sd">        The bytes object can be passed on to a suitable decoder for decoding.</span>

<span class="sd">        :param outputfile: Optional, an output file if the result needs to be stored on disk.</span>
<span class="sd">        :param format: Optional, an output format supported by the backend.</span>
<span class="sd">        :param options: Optional, file format options</span>
<span class="sd">        :return: None if the result is stored to disk, or a bytes object returned by the backend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">format</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="n">guess_format</span><span class="p">(</span><span class="n">outputfile</span><span class="p">)</span> <span class="k">if</span> <span class="n">outputfile</span> <span class="k">else</span> <span class="s2">&quot;GTiff&quot;</span>
        <span class="c1"># TODO: only add `save_result` node when there is none yet?</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_result</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span> <span class="n">outputfile</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.validate"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate a process graph without executing it.</span>

<span class="sd">        :return: list of errors (dictionaries with &quot;code&quot; and &quot;message&quot; fields)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">validate_process_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">tiled_viewing_service</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Service</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">create_service</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.execute_batch"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.execute_batch">[docs]</a>    <span class="k">def</span> <span class="nf">execute_batch</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">outputfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="nb">print</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">max_poll_interval</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">connection_retry_interval</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
            <span class="n">job_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">format_options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchJob</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the process graph by creating a batch job, and retrieving the results when it is finished.</span>
<span class="sd">        This method is mostly recommended if the batch job is expected to run in a reasonable amount of time.</span>

<span class="sd">        For very long running jobs, you probably do not want to keep the client running.</span>

<span class="sd">        :param job_options:</span>
<span class="sd">        :param outputfile: The path of a file to which a result can be written</span>
<span class="sd">        :param out_format: (optional) Format of the job result.</span>
<span class="sd">        :param format_options: String Parameters for the job result format</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">in</span> <span class="n">format_options</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">out_format</span><span class="p">:</span>
            <span class="n">out_format</span> <span class="o">=</span> <span class="n">format_options</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="c1">#align with &#39;download&#39; call arg name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out_format</span><span class="p">:</span>
            <span class="n">out_format</span> <span class="o">=</span> <span class="n">guess_format</span><span class="p">(</span><span class="n">outputfile</span><span class="p">)</span> <span class="k">if</span> <span class="n">outputfile</span> <span class="k">else</span> <span class="s2">&quot;GTiff&quot;</span>
        <span class="n">job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_job</span><span class="p">(</span><span class="n">out_format</span><span class="p">,</span> <span class="n">job_options</span><span class="o">=</span><span class="n">job_options</span><span class="p">,</span> <span class="o">**</span><span class="n">format_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">job</span><span class="o">.</span><span class="n">run_synchronous</span><span class="p">(</span>
            <span class="n">outputfile</span><span class="o">=</span><span class="n">outputfile</span><span class="p">,</span>
            <span class="nb">print</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">max_poll_interval</span><span class="o">=</span><span class="n">max_poll_interval</span><span class="p">,</span> <span class="n">connection_retry_interval</span><span class="o">=</span><span class="n">connection_retry_interval</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.create_job"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.create_job">[docs]</a>    <span class="k">def</span> <span class="nf">create_job</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">out_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">budget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">job_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">format_options</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BatchJob</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends a job to the backend and returns a Job instance. The job will still need to be started and managed explicitly.</span>
<span class="sd">        The :func:`~openeo.imagecollection.ImageCollection.execute_batch` method allows you to run batch jobs without managing it.</span>

<span class="sd">        :param out_format: String Format of the job result.</span>
<span class="sd">        :param job_options: A dictionary containing (custom) job options</span>
<span class="sd">        :param format_options: String Parameters for the job result format</span>
<span class="sd">        :return: status: Job resulting job.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: add option to also automatically start the job?</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">out_format</span><span class="p">:</span>
            <span class="c1"># add `save_result` node</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">save_result</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">out_format</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">format_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">create_job</span><span class="p">(</span>
            <span class="n">process_graph</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">plan</span><span class="o">=</span><span class="n">plan</span><span class="p">,</span> <span class="n">budget</span><span class="o">=</span><span class="n">budget</span><span class="p">,</span> <span class="n">additional</span><span class="o">=</span><span class="n">job_options</span>
        <span class="p">)</span></div>

    <span class="n">send_job</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">create_job</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;send_job&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.save_user_defined_process"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.save_user_defined_process">[docs]</a>    <span class="k">def</span> <span class="nf">save_user_defined_process</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">user_defined_process_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">public</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">summary</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">returns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">categories</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">examples</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">links</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RESTUserDefinedProcess</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves this process graph in the backend as a user-defined process for the authenticated user.</span>

<span class="sd">        :param user_defined_process_id: unique identifier for the process</span>
<span class="sd">        :param public: visible to other users?</span>
<span class="sd">        :param summary: A short summary of what the process does.</span>
<span class="sd">        :param description: Detailed description to explain the entity. CommonMark 0.29 syntax MAY be used for rich text representation.</span>
<span class="sd">        :param returns: Description and schema of the return value.</span>
<span class="sd">        :param categories: A list of categories.</span>
<span class="sd">        :param examples: A list of examples.</span>
<span class="sd">        :param links: A list of links.</span>
<span class="sd">        :return: a RESTUserDefinedProcess instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">save_user_defined_process</span><span class="p">(</span>
            <span class="n">user_defined_process_id</span><span class="o">=</span><span class="n">user_defined_process_id</span><span class="p">,</span>
            <span class="n">process_graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span> <span class="n">public</span><span class="o">=</span><span class="n">public</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="n">summary</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
            <span class="n">returns</span><span class="o">=</span><span class="n">returns</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">categories</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="n">examples</span><span class="p">,</span> <span class="n">links</span><span class="o">=</span><span class="n">links</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.execute"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Executes the process graph of the imagery. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">())</span></div>

<div class="viewcode-block" id="DataCube.execute_local_udf"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.execute_local_udf">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">reason</span><span class="o">=</span><span class="s2">&quot;Use :py:func:`openeo.udf.run_code.execute_local_udf` instead&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.7.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">execute_local_udf</span><span class="p">(</span><span class="n">udf</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">datacube</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;xarray.DataArray&#39;</span><span class="p">,</span> <span class="s1">&#39;XarrayDataCube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;netcdf&#39;</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">openeo.udf.run_code</span>
        <span class="k">return</span> <span class="n">openeo</span><span class="o">.</span><span class="n">udf</span><span class="o">.</span><span class="n">run_code</span><span class="o">.</span><span class="n">execute_local_udf</span><span class="p">(</span><span class="n">udf</span><span class="o">=</span><span class="n">udf</span><span class="p">,</span> <span class="n">datacube</span><span class="o">=</span><span class="n">datacube</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.ard_normalized_radar_backscatter"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.ard_normalized_radar_backscatter">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">ard_normalized_radar_backscatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elevation_model</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">contributing_area</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ellipsoid_incidence_angle</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">noise_removal</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes CARD4L compliant backscatter (gamma0) from SAR input.</span>
<span class="sd">        This method is a variant of :py:meth:`~openeo.rest.datacube.DataCube.sar_backscatter`,</span>
<span class="sd">        with restricted parameters to generate backscatter according to CARD4L specifications.</span>

<span class="sd">        Note that backscatter computation may require instrument specific metadata that is tightly coupled to the original SAR products.</span>
<span class="sd">        As a result, this process may only work in combination with loading data from specific collections, not with general data cubes.</span>

<span class="sd">        :param elevation_model: The digital elevation model to use. Set to None (the default) to allow the back-end to choose, which will improve portability, but reduce reproducibility.</span>
<span class="sd">        :param contributing_area: If set to `true`, a DEM-based local contributing area band named `contributing_area`</span>
<span class="sd">            is added. The values are given in square meters.</span>
<span class="sd">        :param ellipsoid_incidence_angle: If set to `True`, an ellipsoidal incidence angle band named `ellipsoid_incidence_angle` is added. The values are given in degrees.</span>
<span class="sd">        :param noise_removal: If set to `false`, no noise removal is applied. Defaults to `True`, which removes noise.</span>

<span class="sd">        :return: Backscatter values expressed as gamma0. The data returned is CARD4L compliant and contains metadata. By default, the backscatter values are given in linear scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;ard_normalized_radar_backscatter&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;elevation_model&quot;</span><span class="p">:</span> <span class="n">elevation_model</span><span class="p">,</span>
            <span class="s2">&quot;contributing_area&quot;</span><span class="p">:</span> <span class="n">contributing_area</span><span class="p">,</span>
            <span class="s2">&quot;ellipsoid_incidence_angle&quot;</span><span class="p">:</span> <span class="n">ellipsoid_incidence_angle</span><span class="p">,</span>
            <span class="s2">&quot;noise_removal&quot;</span><span class="p">:</span> <span class="n">noise_removal</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.sar_backscatter"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.sar_backscatter">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">sar_backscatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">coefficient</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gamma0-terrain&quot;</span><span class="p">,</span>
            <span class="n">elevation_model</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">contributing_area</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">local_incidence_angle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">ellipsoid_incidence_angle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">noise_removal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes backscatter from SAR input.</span>

<span class="sd">        Note that backscatter computation may require instrument specific metadata that is tightly coupled to the</span>
<span class="sd">        original SAR products. As a result, this process may only work in combination with loading data from</span>
<span class="sd">        specific collections, not with general data cubes.</span>

<span class="sd">        :param coefficient: Select the radiometric correction coefficient.</span>
<span class="sd">            The following options are available:</span>

<span class="sd">            - `&quot;beta0&quot;`: radar brightness</span>
<span class="sd">            - `&quot;sigma0-ellipsoid&quot;`: ground area computed with ellipsoid earth model</span>
<span class="sd">            - `&quot;sigma0-terrain&quot;`: ground area computed with terrain earth model</span>
<span class="sd">            - `&quot;gamma0-ellipsoid&quot;`: ground area computed with ellipsoid earth model in sensor line of sight</span>
<span class="sd">            - `&quot;gamma0-terrain&quot;`: ground area computed with terrain earth model in sensor line of sight (default)</span>
<span class="sd">            - `None`: non-normalized backscatter</span>
<span class="sd">        :param elevation_model: The digital elevation model to use. Set to `None` (the default) to allow</span>
<span class="sd">            the back-end to choose, which will improve portability, but reduce reproducibility.</span>
<span class="sd">        :param mask: If set to `true`, a data mask is added to the bands with the name `mask`.</span>
<span class="sd">            It indicates which values are valid (1), invalid (0) or contain no-data (null).</span>
<span class="sd">        :param contributing_area: If set to `true`, a DEM-based local contributing area band named `contributing_area`</span>
<span class="sd">            is added. The values are given in square meters.</span>
<span class="sd">        :param local_incidence_angle: If set to `true`, a DEM-based local incidence angle band named</span>
<span class="sd">            `local_incidence_angle` is added. The values are given in degrees.</span>
<span class="sd">        :param ellipsoid_incidence_angle: If set to `true`, an ellipsoidal incidence angle band named</span>
<span class="sd">            `ellipsoid_incidence_angle` is added. The values are given in degrees.</span>
<span class="sd">        :param noise_removal: If set to `false`, no noise removal is applied. Defaults to `true`, which removes noise.</span>
<span class="sd">        :param options: dictionary with additional (backend-specific) options.</span>
<span class="sd">        :return:</span>

<span class="sd">        .. versionadded:: 0.4.9</span>
<span class="sd">        .. versionchanged:: 0.4.10 replace `orthorectify` and `rtc` arguments with `coefficient`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coefficient_options</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;beta0&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma0-ellipsoid&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma0-terrain&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma0-ellipsoid&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma0-terrain&quot;</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">coefficient</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coefficient_options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenEoClientException</span><span class="p">(</span><span class="s2">&quot;Invalid `sar_backscatter` coefficient </span><span class="si">{c!r}</span><span class="s2">. Should be one of </span><span class="si">{o}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">c</span><span class="o">=</span><span class="n">coefficient</span><span class="p">,</span> <span class="n">o</span><span class="o">=</span><span class="n">coefficient_options</span>
            <span class="p">))</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;coefficient&quot;</span><span class="p">:</span> <span class="n">coefficient</span><span class="p">,</span>
            <span class="s2">&quot;elevation_model&quot;</span><span class="p">:</span> <span class="n">elevation_model</span><span class="p">,</span>
            <span class="s2">&quot;mask&quot;</span><span class="p">:</span> <span class="n">mask</span><span class="p">,</span>
            <span class="s2">&quot;contributing_area&quot;</span><span class="p">:</span> <span class="n">contributing_area</span><span class="p">,</span>
            <span class="s2">&quot;local_incidence_angle&quot;</span><span class="p">:</span> <span class="n">local_incidence_angle</span><span class="p">,</span>
            <span class="s2">&quot;ellipsoid_incidence_angle&quot;</span><span class="p">:</span> <span class="n">ellipsoid_incidence_angle</span><span class="p">,</span>
            <span class="s2">&quot;noise_removal&quot;</span><span class="p">:</span> <span class="n">noise_removal</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;sar_backscatter&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.fit_curve"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.fit_curve">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">fit_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use non-linear least squares to fit a model function `y = f(x, parameters)` to data.</span>

<span class="sd">        The process throws an `InvalidValues` exception if invalid values are encountered.</span>
<span class="sd">        Invalid values are finite numbers (see also ``is_valid()``).</span>

<span class="sd">        .. warning:: experimental process: not generally supported, API subject to change.</span>
<span class="sd">            https://github.com/Open-EO/openeo-processes/pull/240</span>

<span class="sd">        :param parameters:</span>
<span class="sd">        :param function: &quot;child callback&quot; function, see :ref:`callbackfunctions`</span>
<span class="sd">        :param dimension:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;fit_curve&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="n">parameters</span><span class="p">,</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;parameters&quot;</span><span class="p">]),</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="n">dimension</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.predict_curve"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.predict_curve">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">predict_curve</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict values using a model function and pre-computed parameters.</span>

<span class="sd">        .. warning:: experimental process: not generally supported, API subject to change.</span>
<span class="sd">            https://github.com/Open-EO/openeo-processes/pull/240</span>

<span class="sd">        :param parameters:</span>
<span class="sd">        :param function: &quot;child callback&quot; function, see :ref:`callbackfunctions`</span>
<span class="sd">        :param dimension:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;predict_curve&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="n">parameters</span><span class="p">,</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;parameters&quot;</span><span class="p">]),</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="n">dimension</span><span class="p">,</span>
            <span class="s2">&quot;labels&quot;</span><span class="p">:</span> <span class="n">labels</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.predict_random_forest"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.predict_random_forest">[docs]</a>    <span class="nd">@openeo_process</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">predict_random_forest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BatchJob</span><span class="p">,</span> <span class="n">MlModel</span><span class="p">],</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;bands&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply ``reduce_dimension`` process with a ``predict_random_forest`` reducer.</span>

<span class="sd">        :param model: a reference to a trained model, one of</span>

<span class="sd">                - a :py:class:`MlModel` instance (e.g. loaded from :py:meth:`Connection.load_ml_model`)</span>
<span class="sd">                - a :py:class:`BatchJob` instance of a batch job that saved a single random forest model</span>
<span class="sd">                - a job id (``str``) of a batch job that saved a single random forest model</span>
<span class="sd">                - a STAC item URL (``str``) to load the random forest from.</span>
<span class="sd">                  (The STAC Item must implement the `ml-model` extension.)</span>
<span class="sd">        :param dimension: dimension along which to apply the ``reduce_dimension`` process.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">MlModel</span><span class="p">):</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">MlModel</span><span class="o">.</span><span class="n">load_ml_model</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">openeo.processes</span> <span class="kn">import</span> <span class="n">predict_random_forest</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">predict_random_forest</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.dimension_labels"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.dimension_labels">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">dimension_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives all labels for a dimension in the data cube. The labels have the same order as in the data cube.</span>

<span class="sd">        :param dimension: The name of the dimension to get the labels for.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimension_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dimension_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dimension_names</span> <span class="ow">and</span> <span class="n">dimension</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dimension_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid dimension name </span><span class="si">{</span><span class="n">dimension</span><span class="si">!r}</span><span class="s2">, should be one of </span><span class="si">{</span><span class="n">dimension_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;dimension_labels&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span> <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="n">dimension</span><span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.fit_class_random_forest"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.fit_class_random_forest">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">fit_class_random_forest</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="c1"># TODO #279 #293: target type should be `VectorCube` (with adapters for GeoJSON FeatureCollection, GeoPandas, ...)</span>
            <span class="n">target</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="c1"># TODO #293 max_variables officially has no default</span>
            <span class="n">max_variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">num_trees</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
            <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MlModel&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the fit of a random forest classification based on the user input of target and predictors.</span>
<span class="sd">        The Random Forest classification model is based on the approach by Breiman (2001).</span>

<span class="sd">        .. warning:: EXPERIMENTAL: not generally supported, API subject to change.</span>

<span class="sd">        :param target: The training sites for the classification model as a vector data cube. This is associated with the target</span>
<span class="sd">            variable for the Random Forest model. The geometry has to be associated with a value to predict (e.g. fractional</span>
<span class="sd">            forest canopy cover).</span>
<span class="sd">        :param max_variables: Specifies how many split variables will be used at a node. Default value is `null`, which corresponds to the</span>
<span class="sd">            number of predictors divided by 3.</span>
<span class="sd">        :param num_trees: The number of trees build within the Random Forest classification.</span>
<span class="sd">        :param seed: A randomization seed to use for the random sampling in training.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO #279: `fit_class_random_forest` should be defined on VectorCube instead of DataCube</span>
        <span class="n">pgnode</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;fit_class_random_forest&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">predictors</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="c1"># TODO #279 strictly per-spec, target should be a `vector-cube`, but due to lack of proper support we are limited to inline GeoJSON for now</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                <span class="n">max_variables</span><span class="o">=</span><span class="n">max_variables</span><span class="p">,</span>
                <span class="n">num_trees</span><span class="o">=</span><span class="n">num_trees</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MlModel</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pgnode</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span></div>

<div class="viewcode-block" id="DataCube.fit_regr_random_forest"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.fit_regr_random_forest">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">fit_regr_random_forest</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="c1"># TODO #279 #293: target type should be `VectorCube` (with adapters for GeoJSON FeatureCollection, GeoPandas, ...)</span>
            <span class="n">target</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="c1"># TODO #293 max_variables officially has no default</span>
            <span class="n">max_variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">num_trees</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
            <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MlModel&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the fit of a random forest regression based on training data.</span>
<span class="sd">        The Random Forest regression model is based on the approach by Breiman (2001).</span>

<span class="sd">        .. warning:: EXPERIMENTAL: not generally supported, API subject to change.</span>

<span class="sd">        :param target: The training sites for the regression model as a vector data cube.</span>
<span class="sd">            This is associated with the target variable for the Random Forest model.</span>
<span class="sd">            The geometry has to associated with a value to predict (e.g. fractional forest canopy cover).</span>
<span class="sd">        :param max_variables: Specifies how many split variables will be used at a node. Default value is `null`, which corresponds to the</span>
<span class="sd">            number of predictors divided by 3.</span>
<span class="sd">        :param num_trees: The number of trees build within the Random Forest classification.</span>
<span class="sd">        :param seed: A randomization seed to use for the random sampling in training.</span>

<span class="sd">        .. versionadded:: 0.10.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO #279 #293: `fit_class_random_forest` should be defined on VectorCube instead of DataCube</span>
        <span class="n">pgnode</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;fit_regr_random_forest&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">predictors</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="c1"># TODO #279 strictly per-spec, target should be a `vector-cube`, but due to lack of proper support we are limited to inline GeoJSON for now</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                <span class="n">max_variables</span><span class="o">=</span><span class="n">max_variables</span><span class="p">,</span>
                <span class="n">num_trees</span><span class="o">=</span><span class="n">num_trees</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MlModel</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pgnode</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span></div>

<div class="viewcode-block" id="DataCube.flatten_dimensions"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.flatten_dimensions">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">flatten_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">target_dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">label_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines multiple given dimensions into a single dimension by flattening the values</span>
<span class="sd">        and merging the dimension labels with the given `label_separator`. Non-string dimension labels will</span>
<span class="sd">        be converted to strings. This process is the opposite of the process :py:meth:`unflatten_dimension()`</span>
<span class="sd">        but executing both processes subsequently doesn&#39;t necessarily create a data cube that</span>
<span class="sd">        is equal to the original data cube.</span>

<span class="sd">        :param dimensions: The names of the dimension to combine.</span>
<span class="sd">        :param target_dimension: The name of a target dimension with a single dimension label to replace.</span>
<span class="sd">        :param label_separator: The string that will be used as a separator for the concatenated dimension labels.</span>
<span class="sd">        :return: A data cube with the new shape.</span>

<span class="sd">        .. warning:: experimental process: not generally supported, API subject to change.</span>
<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;flatten_dimensions&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span>
                <span class="n">target_dimension</span><span class="o">=</span><span class="n">target_dimension</span><span class="p">,</span>
                <span class="n">label_separator</span><span class="o">=</span><span class="n">label_separator</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.unflatten_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.unflatten_dimension">[docs]</a>    <span class="nd">@openeo_process</span>
    <span class="k">def</span> <span class="nf">unflatten_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_dimensions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">label_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a single dimension into multiple dimensions by systematically extracting values and splitting</span>
<span class="sd">        the dimension labels by the given `label_separator`.</span>
<span class="sd">        This process is the opposite of the process :py:meth:`flatten_dimensions()` but executing both processes</span>
<span class="sd">        subsequently doesn&#39;t necessarily create a data cube that is equal to the original data cube.</span>

<span class="sd">        :param dimension: The name of the dimension to split.</span>
<span class="sd">        :param target_dimensions: The names of the target dimensions.</span>
<span class="sd">        :param label_separator: The string that will be used as a separator to split the dimension labels.</span>
<span class="sd">        :return: A data cube with the new shape.</span>

<span class="sd">        .. warning:: experimental process: not generally supported, API subject to change.</span>
<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;unflatten_dimension&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span>
                <span class="n">target_dimensions</span><span class="o">=</span><span class="n">target_dimensions</span><span class="p">,</span>
                <span class="n">label_separator</span><span class="o">=</span><span class="n">label_separator</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">openEO Python Client</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Open-EO&repo=openeo-python-client&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">openEO Python Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_access.html">Finding and loading data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processes.html">Working with processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../batch_jobs.html">Batch Jobs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../udp.html">User-Defined Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auth.html">Authentication and Account Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../udf.html">User-Defined Functions (UDF) explained</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datacube_construction.html">DataCube construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../machine_learning.html">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cookbook/index.html">openEO CookBook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process_mapping.html">openEO Process Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Development and maintenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../best_practices.html">Best practices, coding style and general tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Alabaster (krTheme++) Hacks -->

<div class="sidebar-meta">
<h3>Meta</h3>
<div>Docs for openEO Python Client</div>
<div>Version: <code>0.12.0a1</code></div>
<div>Last updated: 2022/08/26</div>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017 - 2022, Jeroen Dries.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/Open-EO/openeo-python-client" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>